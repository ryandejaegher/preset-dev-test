'use strict';

const fs$2 = require('fs-extra');
const fs$1 = require('node:fs');
const path$3 = require('node:path');
const node_buffer = require('node:buffer');
const childProcess = require('node:child_process');
const process$2 = require('node:process');
const require$$0$2 = require('child_process');
const require$$0$1 = require('path');
const require$$0 = require('fs');
const node_url = require('node:url');
const os = require('node:os');
const promises = require('node:timers/promises');
const require$$0$3 = require('stream');
const node_util = require('node:util');
const createDebugger = require('debug');
const createEvents = require('mitt');
const node_crypto = require('node:crypto');
const node_perf_hooks = require('node:perf_hooks');
const cac = require('cac');
const simpleGit = require('simple-git');
const node_module = require('node:module');
const vm = require('node:vm');
const esbuild = require('esbuild');
const unconfig = require('unconfig');
const fg = require('fast-glob');
const unset = require('unset-value');
const merge = require('deepmerge');

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

const fs__default$1 = /*#__PURE__*/_interopDefaultCompat(fs$2);
const fs__default = /*#__PURE__*/_interopDefaultCompat(fs$1);
const path__default = /*#__PURE__*/_interopDefaultCompat(path$3);
const childProcess__default = /*#__PURE__*/_interopDefaultCompat(childProcess);
const process__default = /*#__PURE__*/_interopDefaultCompat(process$2);
const require$$0__default$2 = /*#__PURE__*/_interopDefaultCompat(require$$0$2);
const require$$0__default$1 = /*#__PURE__*/_interopDefaultCompat(require$$0$1);
const require$$0__default = /*#__PURE__*/_interopDefaultCompat(require$$0);
const os__default = /*#__PURE__*/_interopDefaultCompat(os);
const require$$0__default$3 = /*#__PURE__*/_interopDefaultCompat(require$$0$3);
const createDebugger__default = /*#__PURE__*/_interopDefaultCompat(createDebugger);
const createEvents__default = /*#__PURE__*/_interopDefaultCompat(createEvents);
const cac__default = /*#__PURE__*/_interopDefaultCompat(cac);
const simpleGit__default = /*#__PURE__*/_interopDefaultCompat(simpleGit);
const vm__default = /*#__PURE__*/_interopDefaultCompat(vm);
const fg__default = /*#__PURE__*/_interopDefaultCompat(fg);
const unset__default = /*#__PURE__*/_interopDefaultCompat(unset);
const merge__default = /*#__PURE__*/_interopDefaultCompat(merge);

const preset = {
	__proto__: null,
	get PresetError () { return PresetError; },
	get applyNestedPreset () { return applyNestedPreset; },
	get applyPreset () { return applyPreset; },
	get cloneRepository () { return cloneRepository; },
	get createActionContext () { return createActionContext; },
	get createPresetContext () { return createPresetContext; },
	get defineAction () { return defineAction; },
	get definePreset () { return definePreset; },
	get deletePaths () { return deletePaths; },
	get editFiles () { return editFiles; },
	get emitter () { return emitter; },
	get executeCommand () { return executeCommand; },
	get extractTemplates () { return extractTemplates; },
	get finishActionContext () { return finishActionContext; },
	get finishPresetContext () { return finishPresetContext; },
	get getCurrentPresetContext () { return getCurrentPresetContext; },
	get group () { return group; },
	get importPresetFile () { return importPresetFile; },
	get installPackages () { return installPackages; },
	get parseResolvable () { return parseResolvable; },
	get popCurrentContext () { return popCurrentContext; },
	get prompt () { return prompt; },
	get renamePaths () { return renamePaths; },
	get resolveAlias () { return resolveAlias; },
	get resolveConfiguredAlias () { return resolveConfiguredAlias; },
	get resolveGitHubRepository () { return resolveGitHubRepository; },
	get resolveLocalDirectory () { return resolveLocalDirectory; },
	get resolveLocalFile () { return resolveLocalFile; },
	get resolveNamespacedAlias () { return resolveNamespacedAlias; },
	get resolvePreset () { return resolvePreset; },
	get resolvePresetFile () { return resolvePresetFile; }
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var crossSpawn$1 = {exports: {}};

var windows;
var hasRequiredWindows;

function requireWindows () {
	if (hasRequiredWindows) return windows;
	hasRequiredWindows = 1;
	windows = isexe;
	isexe.sync = sync;

	var fs = require$$0__default;

	function checkPathExt (path, options) {
	  var pathext = options.pathExt !== undefined ?
	    options.pathExt : process.env.PATHEXT;

	  if (!pathext) {
	    return true
	  }

	  pathext = pathext.split(';');
	  if (pathext.indexOf('') !== -1) {
	    return true
	  }
	  for (var i = 0; i < pathext.length; i++) {
	    var p = pathext[i].toLowerCase();
	    if (p && path.substr(-p.length).toLowerCase() === p) {
	      return true
	    }
	  }
	  return false
	}

	function checkStat (stat, path, options) {
	  if (!stat.isSymbolicLink() && !stat.isFile()) {
	    return false
	  }
	  return checkPathExt(path, options)
	}

	function isexe (path, options, cb) {
	  fs.stat(path, function (er, stat) {
	    cb(er, er ? false : checkStat(stat, path, options));
	  });
	}

	function sync (path, options) {
	  return checkStat(fs.statSync(path), path, options)
	}
	return windows;
}

var mode;
var hasRequiredMode;

function requireMode () {
	if (hasRequiredMode) return mode;
	hasRequiredMode = 1;
	mode = isexe;
	isexe.sync = sync;

	var fs = require$$0__default;

	function isexe (path, options, cb) {
	  fs.stat(path, function (er, stat) {
	    cb(er, er ? false : checkStat(stat, options));
	  });
	}

	function sync (path, options) {
	  return checkStat(fs.statSync(path), options)
	}

	function checkStat (stat, options) {
	  return stat.isFile() && checkMode(stat, options)
	}

	function checkMode (stat, options) {
	  var mod = stat.mode;
	  var uid = stat.uid;
	  var gid = stat.gid;

	  var myUid = options.uid !== undefined ?
	    options.uid : process.getuid && process.getuid();
	  var myGid = options.gid !== undefined ?
	    options.gid : process.getgid && process.getgid();

	  var u = parseInt('100', 8);
	  var g = parseInt('010', 8);
	  var o = parseInt('001', 8);
	  var ug = u | g;

	  var ret = (mod & o) ||
	    (mod & g) && gid === myGid ||
	    (mod & u) && uid === myUid ||
	    (mod & ug) && myUid === 0;

	  return ret
	}
	return mode;
}

var core;
if (process.platform === 'win32' || commonjsGlobal.TESTING_WINDOWS) {
  core = requireWindows();
} else {
  core = requireMode();
}

var isexe_1 = isexe$1;
isexe$1.sync = sync;

function isexe$1 (path, options, cb) {
  if (typeof options === 'function') {
    cb = options;
    options = {};
  }

  if (!cb) {
    if (typeof Promise !== 'function') {
      throw new TypeError('callback not provided')
    }

    return new Promise(function (resolve, reject) {
      isexe$1(path, options || {}, function (er, is) {
        if (er) {
          reject(er);
        } else {
          resolve(is);
        }
      });
    })
  }

  core(path, options || {}, function (er, is) {
    // ignore EACCES because that just means we aren't allowed to run it
    if (er) {
      if (er.code === 'EACCES' || options && options.ignoreErrors) {
        er = null;
        is = false;
      }
    }
    cb(er, is);
  });
}

function sync (path, options) {
  // my kingdom for a filtered catch
  try {
    return core.sync(path, options || {})
  } catch (er) {
    if (options && options.ignoreErrors || er.code === 'EACCES') {
      return false
    } else {
      throw er
    }
  }
}

const isWindows = process.platform === 'win32' ||
    process.env.OSTYPE === 'cygwin' ||
    process.env.OSTYPE === 'msys';

const path$2 = require$$0__default$1;
const COLON = isWindows ? ';' : ':';
const isexe = isexe_1;

const getNotFoundError = (cmd) =>
  Object.assign(new Error(`not found: ${cmd}`), { code: 'ENOENT' });

const getPathInfo = (cmd, opt) => {
  const colon = opt.colon || COLON;

  // If it has a slash, then we don't bother searching the pathenv.
  // just check the file itself, and that's it.
  const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? ['']
    : (
      [
        // windows always checks the cwd first
        ...(isWindows ? [process.cwd()] : []),
        ...(opt.path || process.env.PATH ||
          /* istanbul ignore next: very unusual */ '').split(colon),
      ]
    );
  const pathExtExe = isWindows
    ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM'
    : '';
  const pathExt = isWindows ? pathExtExe.split(colon) : [''];

  if (isWindows) {
    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')
      pathExt.unshift('');
  }

  return {
    pathEnv,
    pathExt,
    pathExtExe,
  }
};

const which$1 = (cmd, opt, cb) => {
  if (typeof opt === 'function') {
    cb = opt;
    opt = {};
  }
  if (!opt)
    opt = {};

  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
  const found = [];

  const step = i => new Promise((resolve, reject) => {
    if (i === pathEnv.length)
      return opt.all && found.length ? resolve(found)
        : reject(getNotFoundError(cmd))

    const ppRaw = pathEnv[i];
    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;

    const pCmd = path$2.join(pathPart, cmd);
    const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd
      : pCmd;

    resolve(subStep(p, i, 0));
  });

  const subStep = (p, i, ii) => new Promise((resolve, reject) => {
    if (ii === pathExt.length)
      return resolve(step(i + 1))
    const ext = pathExt[ii];
    isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
      if (!er && is) {
        if (opt.all)
          found.push(p + ext);
        else
          return resolve(p + ext)
      }
      return resolve(subStep(p, i, ii + 1))
    });
  });

  return cb ? step(0).then(res => cb(null, res), cb) : step(0)
};

const whichSync = (cmd, opt) => {
  opt = opt || {};

  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
  const found = [];

  for (let i = 0; i < pathEnv.length; i ++) {
    const ppRaw = pathEnv[i];
    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;

    const pCmd = path$2.join(pathPart, cmd);
    const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd
      : pCmd;

    for (let j = 0; j < pathExt.length; j ++) {
      const cur = p + pathExt[j];
      try {
        const is = isexe.sync(cur, { pathExt: pathExtExe });
        if (is) {
          if (opt.all)
            found.push(cur);
          else
            return cur
        }
      } catch (ex) {}
    }
  }

  if (opt.all && found.length)
    return found

  if (opt.nothrow)
    return null

  throw getNotFoundError(cmd)
};

var which_1 = which$1;
which$1.sync = whichSync;

var pathKey$2 = {exports: {}};

const pathKey$1 = (options = {}) => {
	const environment = options.env || process.env;
	const platform = options.platform || process.platform;

	if (platform !== 'win32') {
		return 'PATH';
	}

	return Object.keys(environment).reverse().find(key => key.toUpperCase() === 'PATH') || 'Path';
};

pathKey$2.exports = pathKey$1;
// TODO: Remove this for the next major release
pathKey$2.exports.default = pathKey$1;

var pathKeyExports = pathKey$2.exports;

const path$1 = require$$0__default$1;
const which = which_1;
const getPathKey = pathKeyExports;

function resolveCommandAttempt(parsed, withoutPathExt) {
    const env = parsed.options.env || process.env;
    const cwd = process.cwd();
    const hasCustomCwd = parsed.options.cwd != null;
    // Worker threads do not have process.chdir()
    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;

    // If a custom `cwd` was specified, we need to change the process cwd
    // because `which` will do stat calls but does not support a custom cwd
    if (shouldSwitchCwd) {
        try {
            process.chdir(parsed.options.cwd);
        } catch (err) {
            /* Empty */
        }
    }

    let resolved;

    try {
        resolved = which.sync(parsed.command, {
            path: env[getPathKey({ env })],
            pathExt: withoutPathExt ? path$1.delimiter : undefined,
        });
    } catch (e) {
        /* Empty */
    } finally {
        if (shouldSwitchCwd) {
            process.chdir(cwd);
        }
    }

    // If we successfully resolved, ensure that an absolute path is returned
    // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it
    if (resolved) {
        resolved = path$1.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);
    }

    return resolved;
}

function resolveCommand$1(parsed) {
    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
}

var resolveCommand_1 = resolveCommand$1;

var _escape = {};

// See http://www.robvanderwoude.com/escapechars.php
const metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;

function escapeCommand(arg) {
    // Escape meta chars
    arg = arg.replace(metaCharsRegExp, '^$1');

    return arg;
}

function escapeArgument(arg, doubleEscapeMetaChars) {
    // Convert to string
    arg = `${arg}`;

    // Algorithm below is based on https://qntm.org/cmd

    // Sequence of backslashes followed by a double quote:
    // double up all the backslashes and escape the double quote
    arg = arg.replace(/(\\*)"/g, '$1$1\\"');

    // Sequence of backslashes followed by the end of the string
    // (which will become a double quote later):
    // double up all the backslashes
    arg = arg.replace(/(\\*)$/, '$1$1');

    // All other backslashes occur literally

    // Quote the whole thing:
    arg = `"${arg}"`;

    // Escape meta chars
    arg = arg.replace(metaCharsRegExp, '^$1');

    // Double escape meta chars if necessary
    if (doubleEscapeMetaChars) {
        arg = arg.replace(metaCharsRegExp, '^$1');
    }

    return arg;
}

_escape.command = escapeCommand;
_escape.argument = escapeArgument;

var shebangRegex$1 = /^#!(.*)/;

const shebangRegex = shebangRegex$1;

var shebangCommand$1 = (string = '') => {
	const match = string.match(shebangRegex);

	if (!match) {
		return null;
	}

	const [path, argument] = match[0].replace(/#! ?/, '').split(' ');
	const binary = path.split('/').pop();

	if (binary === 'env') {
		return argument;
	}

	return argument ? `${binary} ${argument}` : binary;
};

const fs = require$$0__default;
const shebangCommand = shebangCommand$1;

function readShebang$1(command) {
    // Read the first 150 bytes from the file
    const size = 150;
    const buffer = Buffer.alloc(size);

    let fd;

    try {
        fd = fs.openSync(command, 'r');
        fs.readSync(fd, buffer, 0, size, 0);
        fs.closeSync(fd);
    } catch (e) { /* Empty */ }

    // Attempt to extract shebang (null is returned if not a shebang)
    return shebangCommand(buffer.toString());
}

var readShebang_1 = readShebang$1;

const path = require$$0__default$1;
const resolveCommand = resolveCommand_1;
const escape = _escape;
const readShebang = readShebang_1;

const isWin$1 = process.platform === 'win32';
const isExecutableRegExp = /\.(?:com|exe)$/i;
const isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;

function detectShebang(parsed) {
    parsed.file = resolveCommand(parsed);

    const shebang = parsed.file && readShebang(parsed.file);

    if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;

        return resolveCommand(parsed);
    }

    return parsed.file;
}

function parseNonShell(parsed) {
    if (!isWin$1) {
        return parsed;
    }

    // Detect & add support for shebangs
    const commandFile = detectShebang(parsed);

    // We don't need a shell if the command filename is an executable
    const needsShell = !isExecutableRegExp.test(commandFile);

    // If a shell is required, use cmd.exe and take care of escaping everything correctly
    // Note that `forceShell` is an hidden option used only in tests
    if (parsed.options.forceShell || needsShell) {
        // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`
        // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument
        // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,
        // we need to double escape them
        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);

        // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\bar)
        // This is necessary otherwise it will always fail with ENOENT in those cases
        parsed.command = path.normalize(parsed.command);

        // Escape command & arguments
        parsed.command = escape.command(parsed.command);
        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));

        const shellCommand = [parsed.command].concat(parsed.args).join(' ');

        parsed.args = ['/d', '/s', '/c', `"${shellCommand}"`];
        parsed.command = process.env.comspec || 'cmd.exe';
        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped
    }

    return parsed;
}

function parse$1(command, args, options) {
    // Normalize arguments, similar to nodejs
    if (args && !Array.isArray(args)) {
        options = args;
        args = null;
    }

    args = args ? args.slice(0) : []; // Clone array to avoid changing the original
    options = Object.assign({}, options); // Clone object to avoid changing the original

    // Build our parsed object
    const parsed = {
        command,
        args,
        options,
        file: undefined,
        original: {
            command,
            args,
        },
    };

    // Delegate further parsing to shell or non-shell
    return options.shell ? parsed : parseNonShell(parsed);
}

var parse_1 = parse$1;

const isWin = process.platform === 'win32';

function notFoundError(original, syscall) {
    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: 'ENOENT',
        errno: 'ENOENT',
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args,
    });
}

function hookChildProcess(cp, parsed) {
    if (!isWin) {
        return;
    }

    const originalEmit = cp.emit;

    cp.emit = function (name, arg1) {
        // If emitting "exit" event and exit code is 1, we need to check if
        // the command exists and emit an "error" instead
        // See https://github.com/IndigoUnited/node-cross-spawn/issues/16
        if (name === 'exit') {
            const err = verifyENOENT(arg1, parsed);

            if (err) {
                return originalEmit.call(cp, 'error', err);
            }
        }

        return originalEmit.apply(cp, arguments); // eslint-disable-line prefer-rest-params
    };
}

function verifyENOENT(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, 'spawn');
    }

    return null;
}

function verifyENOENTSync(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, 'spawnSync');
    }

    return null;
}

var enoent$1 = {
    hookChildProcess,
    verifyENOENT,
    verifyENOENTSync,
    notFoundError,
};

const cp = require$$0__default$2;
const parse = parse_1;
const enoent = enoent$1;

function spawn(command, args, options) {
    // Parse the arguments
    const parsed = parse(command, args, options);

    // Spawn the child process
    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);

    // Hook into child process "exit" event to emit an error if the command
    // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
    enoent.hookChildProcess(spawned, parsed);

    return spawned;
}

function spawnSync(command, args, options) {
    // Parse the arguments
    const parsed = parse(command, args, options);

    // Spawn the child process
    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);

    // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);

    return result;
}

crossSpawn$1.exports = spawn;
crossSpawn$1.exports.spawn = spawn;
crossSpawn$1.exports.sync = spawnSync;

crossSpawn$1.exports._parse = parse;
crossSpawn$1.exports._enoent = enoent;

var crossSpawnExports = crossSpawn$1.exports;
const crossSpawn = /*@__PURE__*/getDefaultExportFromCjs(crossSpawnExports);

function stripFinalNewline(input) {
	const LF = typeof input === 'string' ? '\n' : '\n'.charCodeAt();
	const CR = typeof input === 'string' ? '\r' : '\r'.charCodeAt();

	if (input[input.length - 1] === LF) {
		input = input.slice(0, -1);
	}

	if (input[input.length - 1] === CR) {
		input = input.slice(0, -1);
	}

	return input;
}

function pathKey(options = {}) {
	const {
		env = process.env,
		platform = process.platform
	} = options;

	if (platform !== 'win32') {
		return 'PATH';
	}

	return Object.keys(env).reverse().find(key => key.toUpperCase() === 'PATH') || 'Path';
}

const npmRunPath = ({
	cwd = process__default.cwd(),
	path: pathOption = process__default.env[pathKey()],
	preferLocal = true,
	execPath = process__default.execPath,
	addExecPath = true,
} = {}) => {
	const cwdString = cwd instanceof URL ? node_url.fileURLToPath(cwd) : cwd;
	const cwdPath = path__default.resolve(cwdString);
	const result = [];

	if (preferLocal) {
		applyPreferLocal(result, cwdPath);
	}

	if (addExecPath) {
		applyExecPath(result, execPath, cwdPath);
	}

	return [...result, pathOption].join(path__default.delimiter);
};

const applyPreferLocal = (result, cwdPath) => {
	let previous;

	while (previous !== cwdPath) {
		result.push(path__default.join(cwdPath, 'node_modules/.bin'));
		previous = cwdPath;
		cwdPath = path__default.resolve(cwdPath, '..');
	}
};

// Ensure the running `node` binary is used
const applyExecPath = (result, execPath, cwdPath) => {
	const execPathString = execPath instanceof URL ? node_url.fileURLToPath(execPath) : execPath;
	result.push(path__default.resolve(cwdPath, execPathString, '..'));
};

const npmRunPathEnv = ({env = process__default.env, ...options} = {}) => {
	env = {...env};

	const pathName = pathKey({env});
	options.path = env[pathName];
	env[pathName] = npmRunPath(options);

	return env;
};

const copyProperty = (to, from, property, ignoreNonConfigurable) => {
	// `Function#length` should reflect the parameters of `to` not `from` since we keep its body.
	// `Function#prototype` is non-writable and non-configurable so can never be modified.
	if (property === 'length' || property === 'prototype') {
		return;
	}

	// `Function#arguments` and `Function#caller` should not be copied. They were reported to be present in `Reflect.ownKeys` for some devices in React Native (#41), so we explicitly ignore them here.
	if (property === 'arguments' || property === 'caller') {
		return;
	}

	const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
	const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);

	if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
		return;
	}

	Object.defineProperty(to, property, fromDescriptor);
};

// `Object.defineProperty()` throws if the property exists, is not configurable and either:
// - one its descriptors is changed
// - it is non-writable and its value is changed
const canCopyProperty = function (toDescriptor, fromDescriptor) {
	return toDescriptor === undefined || toDescriptor.configurable || (
		toDescriptor.writable === fromDescriptor.writable &&
		toDescriptor.enumerable === fromDescriptor.enumerable &&
		toDescriptor.configurable === fromDescriptor.configurable &&
		(toDescriptor.writable || toDescriptor.value === fromDescriptor.value)
	);
};

const changePrototype = (to, from) => {
	const fromPrototype = Object.getPrototypeOf(from);
	if (fromPrototype === Object.getPrototypeOf(to)) {
		return;
	}

	Object.setPrototypeOf(to, fromPrototype);
};

const wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/\n${fromBody}`;

const toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, 'toString');
const toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, 'name');

// We call `from.toString()` early (not lazily) to ensure `from` can be garbage collected.
// We use `bind()` instead of a closure for the same reason.
// Calling `from.toString()` early also allows caching it in case `to.toString()` is called several times.
const changeToString = (to, from, name) => {
	const withName = name === '' ? '' : `with ${name.trim()}() `;
	const newToString = wrappedToString.bind(null, withName, from.toString());
	// Ensure `to.toString.toString` is non-enumerable and has the same `same`
	Object.defineProperty(newToString, 'name', toStringName);
	Object.defineProperty(to, 'toString', {...toStringDescriptor, value: newToString});
};

function mimicFunction(to, from, {ignoreNonConfigurable = false} = {}) {
	const {name} = to;

	for (const property of Reflect.ownKeys(from)) {
		copyProperty(to, from, property, ignoreNonConfigurable);
	}

	changePrototype(to, from);
	changeToString(to, from, name);

	return to;
}

const calledFunctions = new WeakMap();

const onetime = (function_, options = {}) => {
	if (typeof function_ !== 'function') {
		throw new TypeError('Expected a function');
	}

	let returnValue;
	let callCount = 0;
	const functionName = function_.displayName || function_.name || '<anonymous>';

	const onetime = function (...arguments_) {
		calledFunctions.set(onetime, ++callCount);

		if (callCount === 1) {
			returnValue = function_.apply(this, arguments_);
			function_ = null;
		} else if (options.throw === true) {
			throw new Error(`Function \`${functionName}\` can only be called once`);
		}

		return returnValue;
	};

	mimicFunction(onetime, function_);
	calledFunctions.set(onetime, callCount);

	return onetime;
};

onetime.callCount = function_ => {
	if (!calledFunctions.has(function_)) {
		throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
	}

	return calledFunctions.get(function_);
};

const getRealtimeSignals=()=>{
const length=SIGRTMAX-SIGRTMIN+1;
return Array.from({length},getRealtimeSignal)
};

const getRealtimeSignal=(value,index)=>({
name:`SIGRT${index+1}`,
number:SIGRTMIN+index,
action:"terminate",
description:"Application-specific signal (realtime)",
standard:"posix"
});

const SIGRTMIN=34;
const SIGRTMAX=64;

const SIGNALS=[
{
name:"SIGHUP",
number:1,
action:"terminate",
description:"Terminal closed",
standard:"posix"
},
{
name:"SIGINT",
number:2,
action:"terminate",
description:"User interruption with CTRL-C",
standard:"ansi"
},
{
name:"SIGQUIT",
number:3,
action:"core",
description:"User interruption with CTRL-\\",
standard:"posix"
},
{
name:"SIGILL",
number:4,
action:"core",
description:"Invalid machine instruction",
standard:"ansi"
},
{
name:"SIGTRAP",
number:5,
action:"core",
description:"Debugger breakpoint",
standard:"posix"
},
{
name:"SIGABRT",
number:6,
action:"core",
description:"Aborted",
standard:"ansi"
},
{
name:"SIGIOT",
number:6,
action:"core",
description:"Aborted",
standard:"bsd"
},
{
name:"SIGBUS",
number:7,
action:"core",
description:
"Bus error due to misaligned, non-existing address or paging error",
standard:"bsd"
},
{
name:"SIGEMT",
number:7,
action:"terminate",
description:"Command should be emulated but is not implemented",
standard:"other"
},
{
name:"SIGFPE",
number:8,
action:"core",
description:"Floating point arithmetic error",
standard:"ansi"
},
{
name:"SIGKILL",
number:9,
action:"terminate",
description:"Forced termination",
standard:"posix",
forced:true
},
{
name:"SIGUSR1",
number:10,
action:"terminate",
description:"Application-specific signal",
standard:"posix"
},
{
name:"SIGSEGV",
number:11,
action:"core",
description:"Segmentation fault",
standard:"ansi"
},
{
name:"SIGUSR2",
number:12,
action:"terminate",
description:"Application-specific signal",
standard:"posix"
},
{
name:"SIGPIPE",
number:13,
action:"terminate",
description:"Broken pipe or socket",
standard:"posix"
},
{
name:"SIGALRM",
number:14,
action:"terminate",
description:"Timeout or timer",
standard:"posix"
},
{
name:"SIGTERM",
number:15,
action:"terminate",
description:"Termination",
standard:"ansi"
},
{
name:"SIGSTKFLT",
number:16,
action:"terminate",
description:"Stack is empty or overflowed",
standard:"other"
},
{
name:"SIGCHLD",
number:17,
action:"ignore",
description:"Child process terminated, paused or unpaused",
standard:"posix"
},
{
name:"SIGCLD",
number:17,
action:"ignore",
description:"Child process terminated, paused or unpaused",
standard:"other"
},
{
name:"SIGCONT",
number:18,
action:"unpause",
description:"Unpaused",
standard:"posix",
forced:true
},
{
name:"SIGSTOP",
number:19,
action:"pause",
description:"Paused",
standard:"posix",
forced:true
},
{
name:"SIGTSTP",
number:20,
action:"pause",
description:"Paused using CTRL-Z or \"suspend\"",
standard:"posix"
},
{
name:"SIGTTIN",
number:21,
action:"pause",
description:"Background process cannot read terminal input",
standard:"posix"
},
{
name:"SIGBREAK",
number:21,
action:"terminate",
description:"User interruption with CTRL-BREAK",
standard:"other"
},
{
name:"SIGTTOU",
number:22,
action:"pause",
description:"Background process cannot write to terminal output",
standard:"posix"
},
{
name:"SIGURG",
number:23,
action:"ignore",
description:"Socket received out-of-band data",
standard:"bsd"
},
{
name:"SIGXCPU",
number:24,
action:"core",
description:"Process timed out",
standard:"bsd"
},
{
name:"SIGXFSZ",
number:25,
action:"core",
description:"File too big",
standard:"bsd"
},
{
name:"SIGVTALRM",
number:26,
action:"terminate",
description:"Timeout or timer",
standard:"bsd"
},
{
name:"SIGPROF",
number:27,
action:"terminate",
description:"Timeout or timer",
standard:"bsd"
},
{
name:"SIGWINCH",
number:28,
action:"ignore",
description:"Terminal window size changed",
standard:"bsd"
},
{
name:"SIGIO",
number:29,
action:"terminate",
description:"I/O is available",
standard:"other"
},
{
name:"SIGPOLL",
number:29,
action:"terminate",
description:"Watched event",
standard:"other"
},
{
name:"SIGINFO",
number:29,
action:"ignore",
description:"Request for process information",
standard:"other"
},
{
name:"SIGPWR",
number:30,
action:"terminate",
description:"Device running out of power",
standard:"systemv"
},
{
name:"SIGSYS",
number:31,
action:"core",
description:"Invalid system call",
standard:"other"
},
{
name:"SIGUNUSED",
number:31,
action:"terminate",
description:"Invalid system call",
standard:"other"
}];

const getSignals=()=>{
const realtimeSignals=getRealtimeSignals();
const signals=[...SIGNALS,...realtimeSignals].map(normalizeSignal);
return signals
};







const normalizeSignal=({
name,
number:defaultNumber,
description,
action,
forced=false,
standard
})=>{
const{
signals:{[name]:constantSignal}
}=os.constants;
const supported=constantSignal!==undefined;
const number=supported?constantSignal:defaultNumber;
return {name,number,description,supported,action,forced,standard}
};

const getSignalsByName=()=>{
const signals=getSignals();
return Object.fromEntries(signals.map(getSignalByName))
};

const getSignalByName=({
name,
number,
description,
supported,
action,
forced,
standard
})=>[name,{name,number,description,supported,action,forced,standard}];

const signalsByName=getSignalsByName();




const getSignalsByNumber=()=>{
const signals=getSignals();
const length=SIGRTMAX+1;
const signalsA=Array.from({length},(value,number)=>
getSignalByNumber(number,signals)
);
return Object.assign({},...signalsA)
};

const getSignalByNumber=(number,signals)=>{
const signal=findSignalByNumber(number,signals);

if(signal===undefined){
return {}
}

const{name,description,supported,action,forced,standard}=signal;
return {
[number]:{
name,
number,
description,
supported,
action,
forced,
standard
}
}
};



const findSignalByNumber=(number,signals)=>{
const signal=signals.find(({name})=>os.constants.signals[name]===number);

if(signal!==undefined){
return signal
}

return signals.find((signalA)=>signalA.number===number)
};

getSignalsByNumber();

const getErrorPrefix = ({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled}) => {
	if (timedOut) {
		return `timed out after ${timeout} milliseconds`;
	}

	if (isCanceled) {
		return 'was canceled';
	}

	if (errorCode !== undefined) {
		return `failed with ${errorCode}`;
	}

	if (signal !== undefined) {
		return `was killed with ${signal} (${signalDescription})`;
	}

	if (exitCode !== undefined) {
		return `failed with exit code ${exitCode}`;
	}

	return 'failed';
};

const makeError = ({
	stdout,
	stderr,
	all,
	error,
	signal,
	exitCode,
	command,
	escapedCommand,
	timedOut,
	isCanceled,
	killed,
	parsed: {options: {timeout, cwd = process__default.cwd()}},
}) => {
	// `signal` and `exitCode` emitted on `spawned.on('exit')` event can be `null`.
	// We normalize them to `undefined`
	exitCode = exitCode === null ? undefined : exitCode;
	signal = signal === null ? undefined : signal;
	const signalDescription = signal === undefined ? undefined : signalsByName[signal].description;

	const errorCode = error && error.code;

	const prefix = getErrorPrefix({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled});
	const execaMessage = `Command ${prefix}: ${command}`;
	const isError = Object.prototype.toString.call(error) === '[object Error]';
	const shortMessage = isError ? `${execaMessage}\n${error.message}` : execaMessage;
	const message = [shortMessage, stderr, stdout].filter(Boolean).join('\n');

	if (isError) {
		error.originalMessage = error.message;
		error.message = message;
	} else {
		error = new Error(message);
	}

	error.shortMessage = shortMessage;
	error.command = command;
	error.escapedCommand = escapedCommand;
	error.exitCode = exitCode;
	error.signal = signal;
	error.signalDescription = signalDescription;
	error.stdout = stdout;
	error.stderr = stderr;
	error.cwd = cwd;

	if (all !== undefined) {
		error.all = all;
	}

	if ('bufferedData' in error) {
		delete error.bufferedData;
	}

	error.failed = true;
	error.timedOut = Boolean(timedOut);
	error.isCanceled = isCanceled;
	error.killed = killed && !timedOut;

	return error;
};

const aliases = ['stdin', 'stdout', 'stderr'];

const hasAlias = options => aliases.some(alias => options[alias] !== undefined);

const normalizeStdio = options => {
	if (!options) {
		return;
	}

	const {stdio} = options;

	if (stdio === undefined) {
		return aliases.map(alias => options[alias]);
	}

	if (hasAlias(options)) {
		throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map(alias => `\`${alias}\``).join(', ')}`);
	}

	if (typeof stdio === 'string') {
		return stdio;
	}

	if (!Array.isArray(stdio)) {
		throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
	}

	const length = Math.max(stdio.length, aliases.length);
	return Array.from({length}, (value, index) => stdio[index]);
};

/**
 * This is not the set of all possible signals.
 *
 * It IS, however, the set of all signals that trigger
 * an exit on either Linux or BSD systems.  Linux is a
 * superset of the signal names supported on BSD, and
 * the unknown signals just fail to register, so we can
 * catch that easily enough.
 *
 * Windows signals are a different set, since there are
 * signals that terminate Windows processes, but don't
 * terminate (or don't even exist) on Posix systems.
 *
 * Don't bother with SIGKILL.  It's uncatchable, which
 * means that we can't fire any callbacks anyway.
 *
 * If a user does happen to register a handler on a non-
 * fatal signal like SIGWINCH or something, and then
 * exit, it'll end up firing `process.emit('exit')`, so
 * the handler will be fired anyway.
 *
 * SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
 * artificially, inherently leave the process in a
 * state from which it is not safe to try and enter JS
 * listeners.
 */
const signals = [];
signals.push('SIGHUP', 'SIGINT', 'SIGTERM');
if (process.platform !== 'win32') {
    signals.push('SIGALRM', 'SIGABRT', 'SIGVTALRM', 'SIGXCPU', 'SIGXFSZ', 'SIGUSR2', 'SIGTRAP', 'SIGSYS', 'SIGQUIT', 'SIGIOT'
    // should detect profiler and enable/disable accordingly.
    // see #21
    // 'SIGPROF'
    );
}
if (process.platform === 'linux') {
    signals.push('SIGIO', 'SIGPOLL', 'SIGPWR', 'SIGSTKFLT');
}

// Note: since nyc uses this module to output coverage, any lines
// that are in the direct sync flow of nyc's outputCoverage are
// ignored, since we can never get coverage for them.
// grab a reference to node's real process object right away
const processOk = (process) => !!process &&
    typeof process === 'object' &&
    typeof process.removeListener === 'function' &&
    typeof process.emit === 'function' &&
    typeof process.reallyExit === 'function' &&
    typeof process.listeners === 'function' &&
    typeof process.kill === 'function' &&
    typeof process.pid === 'number' &&
    typeof process.on === 'function';
const kExitEmitter = Symbol.for('signal-exit emitter');
const global$1 = globalThis;
const ObjectDefineProperty = Object.defineProperty.bind(Object);
// teeny special purpose ee
class Emitter {
    emitted = {
        afterExit: false,
        exit: false,
    };
    listeners = {
        afterExit: [],
        exit: [],
    };
    count = 0;
    id = Math.random();
    constructor() {
        if (global$1[kExitEmitter]) {
            return global$1[kExitEmitter];
        }
        ObjectDefineProperty(global$1, kExitEmitter, {
            value: this,
            writable: false,
            enumerable: false,
            configurable: false,
        });
    }
    on(ev, fn) {
        this.listeners[ev].push(fn);
    }
    removeListener(ev, fn) {
        const list = this.listeners[ev];
        const i = list.indexOf(fn);
        /* c8 ignore start */
        if (i === -1) {
            return;
        }
        /* c8 ignore stop */
        if (i === 0 && list.length === 1) {
            list.length = 0;
        }
        else {
            list.splice(i, 1);
        }
    }
    emit(ev, code, signal) {
        if (this.emitted[ev]) {
            return false;
        }
        this.emitted[ev] = true;
        let ret = false;
        for (const fn of this.listeners[ev]) {
            ret = fn(code, signal) === true || ret;
        }
        if (ev === 'exit') {
            ret = this.emit('afterExit', code, signal) || ret;
        }
        return ret;
    }
}
class SignalExitBase {
}
const signalExitWrap = (handler) => {
    return {
        onExit(cb, opts) {
            return handler.onExit(cb, opts);
        },
        load() {
            return handler.load();
        },
        unload() {
            return handler.unload();
        },
    };
};
class SignalExitFallback extends SignalExitBase {
    onExit() {
        return () => { };
    }
    load() { }
    unload() { }
}
class SignalExit extends SignalExitBase {
    // "SIGHUP" throws an `ENOSYS` error on Windows,
    // so use a supported signal instead
    /* c8 ignore start */
    #hupSig = process$1.platform === 'win32' ? 'SIGINT' : 'SIGHUP';
    /* c8 ignore stop */
    #emitter = new Emitter();
    #process;
    #originalProcessEmit;
    #originalProcessReallyExit;
    #sigListeners = {};
    #loaded = false;
    constructor(process) {
        super();
        this.#process = process;
        // { <signal>: <listener fn>, ... }
        this.#sigListeners = {};
        for (const sig of signals) {
            this.#sigListeners[sig] = () => {
                // If there are no other listeners, an exit is coming!
                // Simplest way: remove us and then re-send the signal.
                // We know that this will kill the process, so we can
                // safely emit now.
                const listeners = this.#process.listeners(sig);
                let { count } = this.#emitter;
                // This is a workaround for the fact that signal-exit v3 and signal
                // exit v4 are not aware of each other, and each will attempt to let
                // the other handle it, so neither of them do. To correct this, we
                // detect if we're the only handler *except* for previous versions
                // of signal-exit, and increment by the count of listeners it has
                // created.
                /* c8 ignore start */
                const p = process;
                if (typeof p.__signal_exit_emitter__ === 'object' &&
                    typeof p.__signal_exit_emitter__.count === 'number') {
                    count += p.__signal_exit_emitter__.count;
                }
                /* c8 ignore stop */
                if (listeners.length === count) {
                    this.unload();
                    const ret = this.#emitter.emit('exit', null, sig);
                    /* c8 ignore start */
                    const s = sig === 'SIGHUP' ? this.#hupSig : sig;
                    if (!ret)
                        process.kill(process.pid, s);
                    /* c8 ignore stop */
                }
            };
        }
        this.#originalProcessReallyExit = process.reallyExit;
        this.#originalProcessEmit = process.emit;
    }
    onExit(cb, opts) {
        /* c8 ignore start */
        if (!processOk(this.#process)) {
            return () => { };
        }
        /* c8 ignore stop */
        if (this.#loaded === false) {
            this.load();
        }
        const ev = opts?.alwaysLast ? 'afterExit' : 'exit';
        this.#emitter.on(ev, cb);
        return () => {
            this.#emitter.removeListener(ev, cb);
            if (this.#emitter.listeners['exit'].length === 0 &&
                this.#emitter.listeners['afterExit'].length === 0) {
                this.unload();
            }
        };
    }
    load() {
        if (this.#loaded) {
            return;
        }
        this.#loaded = true;
        // This is the number of onSignalExit's that are in play.
        // It's important so that we can count the correct number of
        // listeners on signals, and don't wait for the other one to
        // handle it instead of us.
        this.#emitter.count += 1;
        for (const sig of signals) {
            try {
                const fn = this.#sigListeners[sig];
                if (fn)
                    this.#process.on(sig, fn);
            }
            catch (_) { }
        }
        this.#process.emit = (ev, ...a) => {
            return this.#processEmit(ev, ...a);
        };
        this.#process.reallyExit = (code) => {
            return this.#processReallyExit(code);
        };
    }
    unload() {
        if (!this.#loaded) {
            return;
        }
        this.#loaded = false;
        signals.forEach(sig => {
            const listener = this.#sigListeners[sig];
            /* c8 ignore start */
            if (!listener) {
                throw new Error('Listener not defined for signal: ' + sig);
            }
            /* c8 ignore stop */
            try {
                this.#process.removeListener(sig, listener);
                /* c8 ignore start */
            }
            catch (_) { }
            /* c8 ignore stop */
        });
        this.#process.emit = this.#originalProcessEmit;
        this.#process.reallyExit = this.#originalProcessReallyExit;
        this.#emitter.count -= 1;
    }
    #processReallyExit(code) {
        /* c8 ignore start */
        if (!processOk(this.#process)) {
            return 0;
        }
        this.#process.exitCode = code || 0;
        /* c8 ignore stop */
        this.#emitter.emit('exit', this.#process.exitCode, null);
        return this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode);
    }
    #processEmit(ev, ...args) {
        const og = this.#originalProcessEmit;
        if (ev === 'exit' && processOk(this.#process)) {
            if (typeof args[0] === 'number') {
                this.#process.exitCode = args[0];
                /* c8 ignore start */
            }
            /* c8 ignore start */
            const ret = og.call(this.#process, ev, ...args);
            /* c8 ignore start */
            this.#emitter.emit('exit', this.#process.exitCode, null);
            /* c8 ignore stop */
            return ret;
        }
        else {
            return og.call(this.#process, ev, ...args);
        }
    }
}
const process$1 = globalThis.process;
// wrap so that we call the method on the actual handler, without
// exporting it directly.
const { 
/**
 * Called when the process is exiting, whether via signal, explicit
 * exit, or running out of stuff to do.
 *
 * If the global process object is not suitable for instrumentation,
 * then this will be a no-op.
 *
 * Returns a function that may be used to unload signal-exit.
 */
onExit, 
/**
 * Load the listeners.  Likely you never need to call this, unless
 * doing a rather deep integration with signal-exit functionality.
 * Mostly exposed for the benefit of testing.
 *
 * @internal
 */
load, 
/**
 * Unload the listeners.  Likely you never need to call this, unless
 * doing a rather deep integration with signal-exit functionality.
 * Mostly exposed for the benefit of testing.
 *
 * @internal
 */
unload, } = signalExitWrap(processOk(process$1) ? new SignalExit(process$1) : new SignalExitFallback());

const DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;

// Monkey-patches `childProcess.kill()` to add `forceKillAfterTimeout` behavior
const spawnedKill = (kill, signal = 'SIGTERM', options = {}) => {
	const killResult = kill(signal);
	setKillTimeout(kill, signal, options, killResult);
	return killResult;
};

const setKillTimeout = (kill, signal, options, killResult) => {
	if (!shouldForceKill(signal, options, killResult)) {
		return;
	}

	const timeout = getForceKillAfterTimeout(options);
	const t = setTimeout(() => {
		kill('SIGKILL');
	}, timeout);

	// Guarded because there's no `.unref()` when `execa` is used in the renderer
	// process in Electron. This cannot be tested since we don't run tests in
	// Electron.
	// istanbul ignore else
	if (t.unref) {
		t.unref();
	}
};

const shouldForceKill = (signal, {forceKillAfterTimeout}, killResult) => isSigterm(signal) && forceKillAfterTimeout !== false && killResult;

const isSigterm = signal => signal === os__default.constants.signals.SIGTERM
		|| (typeof signal === 'string' && signal.toUpperCase() === 'SIGTERM');

const getForceKillAfterTimeout = ({forceKillAfterTimeout = true}) => {
	if (forceKillAfterTimeout === true) {
		return DEFAULT_FORCE_KILL_TIMEOUT;
	}

	if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
		throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
	}

	return forceKillAfterTimeout;
};

// `childProcess.cancel()`
const spawnedCancel = (spawned, context) => {
	const killResult = spawned.kill();

	if (killResult) {
		context.isCanceled = true;
	}
};

const timeoutKill = (spawned, signal, reject) => {
	spawned.kill(signal);
	reject(Object.assign(new Error('Timed out'), {timedOut: true, signal}));
};

// `timeout` option handling
const setupTimeout = (spawned, {timeout, killSignal = 'SIGTERM'}, spawnedPromise) => {
	if (timeout === 0 || timeout === undefined) {
		return spawnedPromise;
	}

	let timeoutId;
	const timeoutPromise = new Promise((resolve, reject) => {
		timeoutId = setTimeout(() => {
			timeoutKill(spawned, killSignal, reject);
		}, timeout);
	});

	const safeSpawnedPromise = spawnedPromise.finally(() => {
		clearTimeout(timeoutId);
	});

	return Promise.race([timeoutPromise, safeSpawnedPromise]);
};

const validateTimeout = ({timeout}) => {
	if (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {
		throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
	}
};

// `cleanup` option handling
const setExitHandler = async (spawned, {cleanup, detached}, timedPromise) => {
	if (!cleanup || detached) {
		return timedPromise;
	}

	const removeExitHandler = onExit(() => {
		spawned.kill();
	});

	return timedPromise.finally(() => {
		removeExitHandler();
	});
};

function isStream(stream) {
	return stream !== null
		&& typeof stream === 'object'
		&& typeof stream.pipe === 'function';
}

function isWritableStream(stream) {
	return isStream(stream)
		&& stream.writable !== false
		&& typeof stream._write === 'function'
		&& typeof stream._writableState === 'object';
}

const isExecaChildProcess = target => target instanceof childProcess.ChildProcess && typeof target.then === 'function';

const pipeToTarget = (spawned, streamName, target) => {
	if (typeof target === 'string') {
		spawned[streamName].pipe(fs$1.createWriteStream(target));
		return spawned;
	}

	if (isWritableStream(target)) {
		spawned[streamName].pipe(target);
		return spawned;
	}

	if (!isExecaChildProcess(target)) {
		throw new TypeError('The second argument must be a string, a stream or an Execa child process.');
	}

	if (!isWritableStream(target.stdin)) {
		throw new TypeError('The target child process\'s stdin must be available.');
	}

	spawned[streamName].pipe(target.stdin);
	return target;
};

const addPipeMethods = spawned => {
	if (spawned.stdout !== null) {
		spawned.pipeStdout = pipeToTarget.bind(undefined, spawned, 'stdout');
	}

	if (spawned.stderr !== null) {
		spawned.pipeStderr = pipeToTarget.bind(undefined, spawned, 'stderr');
	}

	if (spawned.all !== undefined) {
		spawned.pipeAll = pipeToTarget.bind(undefined, spawned, 'all');
	}
};

const getStreamContents = async (stream, {init, convertChunk, getSize, truncateChunk, addChunk, getFinalChunk, finalize}, {maxBuffer = Number.POSITIVE_INFINITY} = {}) => {
	if (!isAsyncIterable(stream)) {
		throw new Error('The first argument must be a Readable, a ReadableStream, or an async iterable.');
	}

	const state = init();
	state.length = 0;

	try {
		for await (const chunk of stream) {
			const chunkType = getChunkType(chunk);
			const convertedChunk = convertChunk[chunkType](chunk, state);
			appendChunk({convertedChunk, state, getSize, truncateChunk, addChunk, maxBuffer});
		}

		appendFinalChunk({state, convertChunk, getSize, truncateChunk, addChunk, getFinalChunk, maxBuffer});
		return finalize(state);
	} catch (error) {
		error.bufferedData = finalize(state);
		throw error;
	}
};

const appendFinalChunk = ({state, getSize, truncateChunk, addChunk, getFinalChunk, maxBuffer}) => {
	const convertedChunk = getFinalChunk(state);
	if (convertedChunk !== undefined) {
		appendChunk({convertedChunk, state, getSize, truncateChunk, addChunk, maxBuffer});
	}
};

const appendChunk = ({convertedChunk, state, getSize, truncateChunk, addChunk, maxBuffer}) => {
	const chunkSize = getSize(convertedChunk);
	const newLength = state.length + chunkSize;

	if (newLength <= maxBuffer) {
		addNewChunk(convertedChunk, state, addChunk, newLength);
		return;
	}

	const truncatedChunk = truncateChunk(convertedChunk, maxBuffer - state.length);

	if (truncatedChunk !== undefined) {
		addNewChunk(truncatedChunk, state, addChunk, maxBuffer);
	}

	throw new MaxBufferError();
};

const addNewChunk = (convertedChunk, state, addChunk, newLength) => {
	state.contents = addChunk(convertedChunk, state, newLength);
	state.length = newLength;
};

const isAsyncIterable = stream => typeof stream === 'object' && stream !== null && typeof stream[Symbol.asyncIterator] === 'function';

const getChunkType = chunk => {
	const typeOfChunk = typeof chunk;

	if (typeOfChunk === 'string') {
		return 'string';
	}

	if (typeOfChunk !== 'object' || chunk === null) {
		return 'others';
	}

	// eslint-disable-next-line n/prefer-global/buffer
	if (globalThis.Buffer?.isBuffer(chunk)) {
		return 'buffer';
	}

	const prototypeName = objectToString.call(chunk);

	if (prototypeName === '[object ArrayBuffer]') {
		return 'arrayBuffer';
	}

	if (prototypeName === '[object DataView]') {
		return 'dataView';
	}

	if (
		Number.isInteger(chunk.byteLength)
		&& Number.isInteger(chunk.byteOffset)
		&& objectToString.call(chunk.buffer) === '[object ArrayBuffer]'
	) {
		return 'typedArray';
	}

	return 'others';
};

const {toString: objectToString} = Object.prototype;

class MaxBufferError extends Error {
	name = 'MaxBufferError';

	constructor() {
		super('maxBuffer exceeded');
	}
}

const identity = value => value;

const noop = () => undefined;

const getContentsProp = ({contents}) => contents;

const throwObjectStream = chunk => {
	throw new Error(`Streams in object mode are not supported: ${String(chunk)}`);
};

const getLengthProp = convertedChunk => convertedChunk.length;

async function getStreamAsArrayBuffer(stream, options) {
	return getStreamContents(stream, arrayBufferMethods, options);
}

const initArrayBuffer = () => ({contents: new ArrayBuffer(0)});

const useTextEncoder = chunk => textEncoder.encode(chunk);
const textEncoder = new TextEncoder();

const useUint8Array = chunk => new Uint8Array(chunk);

const useUint8ArrayWithOffset = chunk => new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);

const truncateArrayBufferChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize);

// `contents` is an increasingly growing `Uint8Array`.
const addArrayBufferChunk = (convertedChunk, {contents, length: previousLength}, length) => {
	const newContents = hasArrayBufferResize() ? resizeArrayBuffer(contents, length) : resizeArrayBufferSlow(contents, length);
	new Uint8Array(newContents).set(convertedChunk, previousLength);
	return newContents;
};

// Without `ArrayBuffer.resize()`, `contents` size is always a power of 2.
// This means its last bytes are zeroes (not stream data), which need to be
// trimmed at the end with `ArrayBuffer.slice()`.
const resizeArrayBufferSlow = (contents, length) => {
	if (length <= contents.byteLength) {
		return contents;
	}

	const arrayBuffer = new ArrayBuffer(getNewContentsLength(length));
	new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);
	return arrayBuffer;
};

// With `ArrayBuffer.resize()`, `contents` size matches exactly the size of
// the stream data. It does not include extraneous zeroes to trim at the end.
// The underlying `ArrayBuffer` does allocate a number of bytes that is a power
// of 2, but those bytes are only visible after calling `ArrayBuffer.resize()`.
const resizeArrayBuffer = (contents, length) => {
	if (length <= contents.maxByteLength) {
		contents.resize(length);
		return contents;
	}

	const arrayBuffer = new ArrayBuffer(length, {maxByteLength: getNewContentsLength(length)});
	new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);
	return arrayBuffer;
};

// Retrieve the closest `length` that is both >= and a power of 2
const getNewContentsLength = length => SCALE_FACTOR ** Math.ceil(Math.log(length) / Math.log(SCALE_FACTOR));

const SCALE_FACTOR = 2;

const finalizeArrayBuffer = ({contents, length}) => hasArrayBufferResize() ? contents : contents.slice(0, length);

// `ArrayBuffer.slice()` is slow. When `ArrayBuffer.resize()` is available
// (Node >=20.0.0, Safari >=16.4 and Chrome), we can use it instead.
// eslint-disable-next-line no-warning-comments
// TODO: remove after dropping support for Node 20.
// eslint-disable-next-line no-warning-comments
// TODO: use `ArrayBuffer.transferToFixedLength()` instead once it is available
const hasArrayBufferResize = () => 'resize' in ArrayBuffer.prototype;

const arrayBufferMethods = {
	init: initArrayBuffer,
	convertChunk: {
		string: useTextEncoder,
		buffer: useUint8Array,
		arrayBuffer: useUint8Array,
		dataView: useUint8ArrayWithOffset,
		typedArray: useUint8ArrayWithOffset,
		others: throwObjectStream,
	},
	getSize: getLengthProp,
	truncateChunk: truncateArrayBufferChunk,
	addChunk: addArrayBufferChunk,
	getFinalChunk: noop,
	finalize: finalizeArrayBuffer,
};

async function getStreamAsBuffer(stream, options) {
	if (!('Buffer' in globalThis)) {
		throw new Error('getStreamAsBuffer() is only supported in Node.js');
	}

	try {
		return arrayBufferToNodeBuffer(await getStreamAsArrayBuffer(stream, options));
	} catch (error) {
		if (error.bufferedData !== undefined) {
			error.bufferedData = arrayBufferToNodeBuffer(error.bufferedData);
		}

		throw error;
	}
}

// eslint-disable-next-line n/prefer-global/buffer
const arrayBufferToNodeBuffer = arrayBuffer => globalThis.Buffer.from(arrayBuffer);

async function getStreamAsString(stream, options) {
	return getStreamContents(stream, stringMethods, options);
}

const initString = () => ({contents: '', textDecoder: new TextDecoder()});

const useTextDecoder = (chunk, {textDecoder}) => textDecoder.decode(chunk, {stream: true});

const addStringChunk = (convertedChunk, {contents}) => contents + convertedChunk;

const truncateStringChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize);

const getFinalStringChunk = ({textDecoder}) => {
	const finalChunk = textDecoder.decode();
	return finalChunk === '' ? undefined : finalChunk;
};

const stringMethods = {
	init: initString,
	convertChunk: {
		string: identity,
		buffer: useTextDecoder,
		arrayBuffer: useTextDecoder,
		dataView: useTextDecoder,
		typedArray: useTextDecoder,
		others: throwObjectStream,
	},
	getSize: getLengthProp,
	truncateChunk: truncateStringChunk,
	addChunk: addStringChunk,
	getFinalChunk: getFinalStringChunk,
	finalize: getContentsProp,
};

const { PassThrough } = require$$0__default$3;

var mergeStream = function (/*streams...*/) {
  var sources = [];
  var output  = new PassThrough({objectMode: true});

  output.setMaxListeners(0);

  output.add = add;
  output.isEmpty = isEmpty;

  output.on('unpipe', remove);

  Array.prototype.slice.call(arguments).forEach(add);

  return output

  function add (source) {
    if (Array.isArray(source)) {
      source.forEach(add);
      return this
    }

    sources.push(source);
    source.once('end', remove.bind(null, source));
    source.once('error', output.emit.bind(output, 'error'));
    source.pipe(output, {end: false});
    return this
  }

  function isEmpty () {
    return sources.length == 0;
  }

  function remove (source) {
    sources = sources.filter(function (it) { return it !== source });
    if (!sources.length && output.readable) { output.end(); }
  }
};

const mergeStream$1 = /*@__PURE__*/getDefaultExportFromCjs(mergeStream);

const validateInputOptions = input => {
	if (input !== undefined) {
		throw new TypeError('The `input` and `inputFile` options cannot be both set.');
	}
};

const getInput = ({input, inputFile}) => {
	if (typeof inputFile !== 'string') {
		return input;
	}

	validateInputOptions(input);
	return fs$1.createReadStream(inputFile);
};

// `input` and `inputFile` option in async mode
const handleInput = (spawned, options) => {
	const input = getInput(options);

	if (input === undefined) {
		return;
	}

	if (isStream(input)) {
		input.pipe(spawned.stdin);
	} else {
		spawned.stdin.end(input);
	}
};

// `all` interleaves `stdout` and `stderr`
const makeAllStream = (spawned, {all}) => {
	if (!all || (!spawned.stdout && !spawned.stderr)) {
		return;
	}

	const mixed = mergeStream$1();

	if (spawned.stdout) {
		mixed.add(spawned.stdout);
	}

	if (spawned.stderr) {
		mixed.add(spawned.stderr);
	}

	return mixed;
};

// On failure, `result.stdout|stderr|all` should contain the currently buffered stream
const getBufferedData = async (stream, streamPromise) => {
	// When `buffer` is `false`, `streamPromise` is `undefined` and there is no buffered data to retrieve
	if (!stream || streamPromise === undefined) {
		return;
	}

	// Wait for the `all` stream to receive the last chunk before destroying the stream
	await promises.setTimeout(0);

	stream.destroy();

	try {
		return await streamPromise;
	} catch (error) {
		return error.bufferedData;
	}
};

const getStreamPromise = (stream, {encoding, buffer, maxBuffer}) => {
	if (!stream || !buffer) {
		return;
	}

	// eslint-disable-next-line unicorn/text-encoding-identifier-case
	if (encoding === 'utf8' || encoding === 'utf-8') {
		return getStreamAsString(stream, {maxBuffer});
	}

	if (encoding === null || encoding === 'buffer') {
		return getStreamAsBuffer(stream, {maxBuffer});
	}

	return applyEncoding(stream, maxBuffer, encoding);
};

const applyEncoding = async (stream, maxBuffer, encoding) => {
	const buffer = await getStreamAsBuffer(stream, {maxBuffer});
	return buffer.toString(encoding);
};

// Retrieve result of child process: exit code, signal, error, streams (stdout/stderr/all)
const getSpawnedResult = async ({stdout, stderr, all}, {encoding, buffer, maxBuffer}, processDone) => {
	const stdoutPromise = getStreamPromise(stdout, {encoding, buffer, maxBuffer});
	const stderrPromise = getStreamPromise(stderr, {encoding, buffer, maxBuffer});
	const allPromise = getStreamPromise(all, {encoding, buffer, maxBuffer: maxBuffer * 2});

	try {
		return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
	} catch (error) {
		return Promise.all([
			{error, signal: error.signal, timedOut: error.timedOut},
			getBufferedData(stdout, stdoutPromise),
			getBufferedData(stderr, stderrPromise),
			getBufferedData(all, allPromise),
		]);
	}
};

// eslint-disable-next-line unicorn/prefer-top-level-await
const nativePromisePrototype = (async () => {})().constructor.prototype;

const descriptors = ['then', 'catch', 'finally'].map(property => [
	property,
	Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property),
]);

// The return value is a mixin of `childProcess` and `Promise`
const mergePromise = (spawned, promise) => {
	for (const [property, descriptor] of descriptors) {
		// Starting the main `promise` is deferred to avoid consuming streams
		const value = typeof promise === 'function'
			? (...args) => Reflect.apply(descriptor.value, promise(), args)
			: descriptor.value.bind(promise);

		Reflect.defineProperty(spawned, property, {...descriptor, value});
	}
};

// Use promises instead of `child_process` events
const getSpawnedPromise = spawned => new Promise((resolve, reject) => {
	spawned.on('exit', (exitCode, signal) => {
		resolve({exitCode, signal});
	});

	spawned.on('error', error => {
		reject(error);
	});

	if (spawned.stdin) {
		spawned.stdin.on('error', error => {
			reject(error);
		});
	}
});

const normalizeArgs = (file, args = []) => {
	if (!Array.isArray(args)) {
		return [file];
	}

	return [file, ...args];
};

const NO_ESCAPE_REGEXP = /^[\w.-]+$/;

const escapeArg = arg => {
	if (typeof arg !== 'string' || NO_ESCAPE_REGEXP.test(arg)) {
		return arg;
	}

	return `"${arg.replaceAll('"', '\\"')}"`;
};

const joinCommand = (file, args) => normalizeArgs(file, args).join(' ');

const getEscapedCommand = (file, args) => normalizeArgs(file, args).map(arg => escapeArg(arg)).join(' ');

const verboseDefault = node_util.debuglog('execa').enabled;

const padField = (field, padding) => String(field).padStart(padding, '0');

const getTimestamp = () => {
	const date = new Date();
	return `${padField(date.getHours(), 2)}:${padField(date.getMinutes(), 2)}:${padField(date.getSeconds(), 2)}.${padField(date.getMilliseconds(), 3)}`;
};

const logCommand = (escapedCommand, {verbose}) => {
	if (!verbose) {
		return;
	}

	process__default.stderr.write(`[${getTimestamp()}] ${escapedCommand}\n`);
};

const DEFAULT_MAX_BUFFER = 1000 * 1000 * 100;

const getEnv = ({env: envOption, extendEnv, preferLocal, localDir, execPath}) => {
	const env = extendEnv ? {...process__default.env, ...envOption} : envOption;

	if (preferLocal) {
		return npmRunPathEnv({env, cwd: localDir, execPath});
	}

	return env;
};

const handleArguments = (file, args, options = {}) => {
	const parsed = crossSpawn._parse(file, args, options);
	file = parsed.command;
	args = parsed.args;
	options = parsed.options;

	options = {
		maxBuffer: DEFAULT_MAX_BUFFER,
		buffer: true,
		stripFinalNewline: true,
		extendEnv: true,
		preferLocal: false,
		localDir: options.cwd || process__default.cwd(),
		execPath: process__default.execPath,
		encoding: 'utf8',
		reject: true,
		cleanup: true,
		all: false,
		windowsHide: true,
		verbose: verboseDefault,
		...options,
	};

	options.env = getEnv(options);

	options.stdio = normalizeStdio(options);

	if (process__default.platform === 'win32' && path__default.basename(file, '.exe') === 'cmd') {
		// #116
		args.unshift('/q');
	}

	return {file, args, options, parsed};
};

const handleOutput = (options, value, error) => {
	if (typeof value !== 'string' && !node_buffer.Buffer.isBuffer(value)) {
		// When `execaSync()` errors, we normalize it to '' to mimic `execa()`
		return error === undefined ? undefined : '';
	}

	if (options.stripFinalNewline) {
		return stripFinalNewline(value);
	}

	return value;
};

function execa(file, args, options) {
	const parsed = handleArguments(file, args, options);
	const command = joinCommand(file, args);
	const escapedCommand = getEscapedCommand(file, args);
	logCommand(escapedCommand, parsed.options);

	validateTimeout(parsed.options);

	let spawned;
	try {
		spawned = childProcess__default.spawn(parsed.file, parsed.args, parsed.options);
	} catch (error) {
		// Ensure the returned error is always both a promise and a child process
		const dummySpawned = new childProcess__default.ChildProcess();
		const errorPromise = Promise.reject(makeError({
			error,
			stdout: '',
			stderr: '',
			all: '',
			command,
			escapedCommand,
			parsed,
			timedOut: false,
			isCanceled: false,
			killed: false,
		}));
		mergePromise(dummySpawned, errorPromise);
		return dummySpawned;
	}

	const spawnedPromise = getSpawnedPromise(spawned);
	const timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);
	const processDone = setExitHandler(spawned, parsed.options, timedPromise);

	const context = {isCanceled: false};

	spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));
	spawned.cancel = spawnedCancel.bind(null, spawned, context);

	const handlePromise = async () => {
		const [{error, exitCode, signal, timedOut}, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);
		const stdout = handleOutput(parsed.options, stdoutResult);
		const stderr = handleOutput(parsed.options, stderrResult);
		const all = handleOutput(parsed.options, allResult);

		if (error || exitCode !== 0 || signal !== null) {
			const returnedError = makeError({
				error,
				exitCode,
				signal,
				stdout,
				stderr,
				all,
				command,
				escapedCommand,
				parsed,
				timedOut,
				isCanceled: (parsed.options.signal ? parsed.options.signal.aborted : false),
				killed: spawned.killed,
			});

			if (!parsed.options.reject) {
				return returnedError;
			}

			throw returnedError;
		}

		return {
			command,
			escapedCommand,
			exitCode: 0,
			stdout,
			stderr,
			all,
			failed: false,
			timedOut: false,
			isCanceled: false,
			killed: false,
		};
	};

	const handlePromiseOnce = onetime(handlePromise);

	handleInput(spawned, parsed.options);

	spawned.all = makeAllStream(spawned, parsed.options);

	addPipeMethods(spawned);
	mergePromise(spawned, handlePromiseOnce);
	return spawned;
}

const debug = {
  error: makeDebugger("preset:core:error"),
  apply: makeDebugger("preset:core:apply"),
  resolve: makeDebugger("preset:core:resolve"),
  import: makeDebugger("preset:core:import"),
  context: makeDebugger("preset:core:context"),
  config: makeDebugger("preset:core:config"),
  utils: makeDebugger("preset:core:utils"),
  action: makeDynamicDebugger("preset:core:action"),
  preset: makeDynamicDebugger("preset:core:execution")
};
function makeDebugger(baseName) {
  return createDebugger__default(baseName);
}
function makeDynamicDebugger(baseName) {
  return (name, content, ...args) => createDebugger__default(`${baseName}:${name}`)(content, ...args);
}
function wrap(value) {
  if (!value) {
    return [];
  }
  if (!Array.isArray(value)) {
    value = [value];
  }
  return value;
}
function invoke(fn) {
  return fn();
}
async function execute(command, args = [], fn, cwd, options = {}, ignoreExitCode = false) {
  const result = execa(command, args, {
    cwd,
    all: true,
    ...options
  });
  result.all?.on("data", (data) => {
    Buffer.from(data).toString("utf-8").split(/[\n\r]/g).map((str) => str.trim()).filter((str) => str.length > 0 && !str.includes("fund")).forEach((str) => fn(str));
  });
  const { failed } = await result;
  return ignoreExitCode ? true : !failed;
}
function objectWithoutKeys(obj, ...keys) {
  return keys.reduce((a, e) => {
    const { [e]: _, ...rest } = a;
    return rest;
  }, obj);
}
async function detectNodePackageManager(directory) {
  const packageManager = process.env.npm_config_user_agent?.split("/")[0];
  if (packageManager && ["npm", "yarn", "pnpm", "bun"].includes(packageManager)) {
    debug.utils(`Detected running package manager: ${packageManager}`);
    return packageManager;
  }
  const packageLockFiles = {
    "bun.lockb": "bun",
    "pnpm-lock.yaml": "pnpm",
    "yarn.lock": "yarn",
    "package-lock.json": "npm"
  };
  for (const [packageLock, packageManager2] of Object.entries(packageLockFiles)) {
    if (fs__default.existsSync(path__default.resolve(directory, packageLock))) {
      debug.utils(`Detected ${packageManager2} in ${directory}`);
      return packageManager2;
    }
  }
  debug.utils(`No package manager detected in ${directory}`);
  return null;
}

const emitter = createEvents__default();

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class PresetError extends Error {
  constructor(error) {
    super();
    __publicField(this, "code");
    __publicField(this, "details");
    __publicField(this, "parent");
    debug.error("An exception has been thrown.", error);
    this.message = error.parent?.message ?? error.details;
    this.stack = error.parent?.stack ?? "";
    this.code = error.code;
    this.details = error.details;
    this.parent = error.parent;
  }
}

const contexts = [];
async function createPresetContext(preset, applyOptions, localPreset) {
  debug.context(`Creating a new context for "${preset.name}".`);
  const { options, args } = cac__default().parse(["", "", ...applyOptions.rawArguments]);
  const context = {
    name: preset.name,
    options: {
      ...preset.options,
      ...options
    },
    preset,
    args,
    id: node_crypto.randomUUID(),
    git: {
      instance: simpleGit__default(),
      config: (await simpleGit__default().listConfig()).all
    },
    count: contexts.length,
    start: node_perf_hooks.performance.now(),
    end: 0,
    actions: [],
    status: "applying",
    applyOptions,
    localPreset,
    prompts: {}
  };
  debug.context("Adding preset context to the stack:", objectWithoutKeys(context, "git"));
  contexts.push(context);
  return context;
}
function createActionContext(presetContext, name, options, groupAction) {
  const context = {
    name,
    options,
    id: node_crypto.randomUUID(),
    presetContextId: presetContext.id,
    groupContextId: groupAction?.id,
    start: node_perf_hooks.performance.now(),
    end: 0,
    status: "applying",
    title: options.title,
    log: []
  };
  debug.context(`Adding action context to ${presetContext.id}:`, context);
  presetContext.actions.push(context);
  return context;
}
function getCurrentPresetContext() {
  debug.context(`Retrieving the current context from the stack (count: ${contexts.length}).`);
  const context = contexts.at(-1);
  if (!context) {
    throw new PresetError({ code: "ERR_MISSING_CONTEXT", details: "Context could not be found in the context stack. This might cause issues." });
  }
  debug.context("Current context:", objectWithoutKeys(context, "git"));
  return context;
}
function finishPresetContext(context, status, error) {
  context.status = status;
  context.end = node_perf_hooks.performance.now();
  if (error) {
    context.error = error;
  }
}
function finishActionContext(action, status, error) {
  action.status = status;
  action.end = node_perf_hooks.performance.now();
  if (error) {
    action.error = error;
  }
}
function popCurrentContext() {
  debug.context("Destroying the current context.");
  if (!contexts.pop()) {
    debug.context("No context found to destroy");
  }
}

function definePreset(preset) {
  if (!preset.name || !preset.handler) {
    throw new PresetError({ code: "ERR_INVALID_PRESET", details: "Preset configuration is missing a name or an handler." });
  }
  return {
    name: preset.name,
    options: preset.options ?? {},
    postInstall: preset.postInstall,
    apply: async (context) => {
      debug.preset(preset.name, `Applying preset "${preset.name}".`);
      emitter.emit("preset:start", context);
      try {
        debug.context(preset.name, "context", objectWithoutKeys(context, "git"));
        debug.preset(preset.name, "Executing handler.");
        if (!process.env.VITEST && !await fs__default$1.pathExists(context.applyOptions.targetDirectory)) {
          debug.preset(preset.name, "Target directory does not exist, creating it.");
          await fs__default$1.ensureDir(context.applyOptions.targetDirectory);
        }
        if (await preset.handler(context) === false) {
          debug.preset(preset.name, "Preset handler returned false, throwing.");
          throw new PresetError({ code: "ERR_PRESET_FAILED", details: "Preset failed to execute properly." });
        }
        if (context.actions.some(({ error }) => Boolean(error))) {
          debug.preset(preset.name, "One or more actions failed.", context.actions.map((action) => ({ name: action.name, error: action.error })));
          throw new PresetError({ code: "ERR_ACTIONS_FAILED", details: "Some of the actions of the preset failed." });
        }
        finishPresetContext(context, "applied");
        debug.preset(preset.name, "Preset handler executed without throwing.");
        emitter.emit("preset:success", context);
      } catch (parent) {
        const error = new PresetError({ code: "ERR_PRESET_FAILED", details: `Preset ${preset.name} threw an error.`, parent });
        finishPresetContext(context, "failed", error);
        emitter.emit("preset:fail", context);
        return false;
      } finally {
        emitter.emit("preset:end", context);
        popCurrentContext();
      }
      return true;
    }
  };
}
function defineAction(name, action, defaultOptions) {
  return async (options) => {
    debug.action(name, `Running action "${name}".`);
    const resolved = {
      ...defaultOptions ?? {},
      ...options ?? {}
    };
    debug.action(name, "Resolved options:", resolved);
    const presetContext = getCurrentPresetContext();
    const groupAction = presetContext.actions.find((action2) => action2.name === "group" && action2.status === "applying");
    const actionContext = createActionContext(presetContext, name, resolved, groupAction);
    emitter.emit("action:start", actionContext);
    try {
      if (!await action({ options: resolved, presetContext, actionContext, name })) {
        throw new PresetError({ code: "ERR_ACTION_FAILED", details: `Action ${name} was not successful.` });
      }
      finishActionContext(actionContext, "applied");
      debug.action(name, "Action handler executed without throwing.");
      emitter.emit("action:success", actionContext);
    } catch (parent) {
      const error = new PresetError({ code: "ERR_ACTION_FAILED", details: `Action ${name} threw an error.`, parent });
      finishActionContext(actionContext, "failed", error);
      emitter.emit("action:fail", actionContext);
    }
    emitter.emit("action:end", actionContext);
  };
}

async function importPresetFile(filepath) {
  debug.import(`Importing ${filepath}.`);
  const script = fs__default.readFileSync(filepath, { encoding: "utf-8" });
  const sanitizedScript = removeSelfImportStatement(script);
  return await evaluateConfiguration(sanitizedScript, path__default.dirname(filepath), filepath);
}
async function evaluateConfiguration(script, directory, filepath) {
  const context = vm__default.createContext(createContext(directory, filepath));
  const code = transformScript(script, directory, filepath);
  vm__default.runInContext(code, context);
  const defaultExportKey = Object.keys(context).find((value) => value.endsWith("_default"));
  if (defaultExportKey) {
    const result = context[defaultExportKey];
    if (!result.name || !result.apply) {
      debug.import(result);
      throw new PresetError({ code: "ERR_INVALID_PRESET", details: "Preset configuration is missing a name or an apply handler." });
    }
    debug.import(`Found default export "${defaultExportKey}":`, result.name);
    return result;
  }
  throw new PresetError({ code: "ERR_PRESET_NO_EXPORT", details: "Preset configuration is missing a default export." });
}
function removeSelfImportStatement(script) {
  debug.import('Removing "import" statements that import the core.');
  return script.split(/\r\n|\r|\n/).filter((line) => {
    const lineImports = ["import", "require"].some((statement) => line.includes(statement));
    const lineMentionsImportValue = ["@preset/core", ...Object.keys(preset)].some((imp) => line.includes(imp));
    if (lineImports && lineMentionsImportValue) {
      return false;
    }
    return true;
  }).join("\n");
}
function transformScript(contents, resolveDir, sourcefile) {
  debug.import("Transforming script with esbuild.");
  const { outputFiles } = esbuild.buildSync({
    stdin: {
      contents,
      resolveDir,
      sourcefile,
      loader: "ts"
    },
    platform: "node",
    format: "cjs",
    external: ["@preset/core"],
    bundle: true,
    write: false
  });
  debug.import(`Transformed ${outputFiles.length} files: `, outputFiles[0].text);
  return outputFiles[0].text;
}
function createContext(directory, filename) {
  debug.import("Creating VM context.");
  const exports = {};
  const require$1 = node_module.createRequire((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.src || new URL('index.cjs', document.baseURI).href)));
  const moduleGlobals = {
    exports,
    require: require$1,
    module: {
      exports,
      filename,
      id: filename,
      path: directory,
      require: require$1
    },
    __dirname: directory,
    __filename: filename
  };
  const nodeGlobals = {
    Buffer,
    clearImmediate,
    clearInterval,
    clearTimeout,
    console,
    global,
    process,
    queueMicrotask,
    setImmediate,
    setInterval,
    setTimeout,
    TextDecoder: globalThis.TextDecorator,
    TextEncoder: globalThis.TextEncoder,
    URL: globalThis.URL,
    URLSearchParams: globalThis.URLSearchParams,
    WebAssembly: globalThis.WebAssembly
  };
  return {
    ...globalThis,
    ...moduleGlobals,
    ...nodeGlobals,
    ...preset
  };
}

const config = {
  defaultNodeAgent: "npm",
  aliases: {}
};
function resetConfig() {
  replaceConfig({
    defaultNodeAgent: "npm",
    aliases: {}
  });
}
function replaceConfig(replacement) {
  for (const [key, value] of Object.entries(replacement)) {
    debug.config("Setting config:", key, value);
    Reflect.set(config, key, value);
  }
  debug.config("Replaced config:", config);
}
async function initializeConfig() {
  debug.config("Initializing config");
  const result = await unconfig.loadConfig({
    cwd: os__default.homedir(),
    sources: {
      files: ["preset", ".presetrc"],
      extensions: ["ts", "mts", "cts", "js", "mjs", "cjs", "json", ""]
    },
    defaults: config
  });
  debug.config("Loaded config:", result);
  replaceConfig(result.config);
  return config;
}

async function resolvePreset(options) {
  const resolved = await parseResolvable(options);
  const emitAndReturn = (resolved2) => {
    debug.apply("Resolved: ", resolved2);
    emitter.emit("preset:resolve", resolved2);
    return resolved2;
  };
  if (resolved.type === "file") {
    return emitAndReturn({
      rootDirectory: path__default.dirname(resolved.path),
      presetFile: resolved.path
    });
  }
  if (resolved.type === "repository") {
    const rootDirectory = await invoke(async () => {
      try {
        return await cloneRepository(resolved, options);
      } catch (error) {
        debug.resolve("Could not clone the repository.");
        if ("parent" in error && error.parent.message.includes("key verification failed")) {
          debug.resolve("Trying again without SSH.");
          return await cloneRepository(resolved, {
            ...options,
            parsedOptions: {
              ...options.parsedOptions,
              ssh: false
            }
          });
        }
        throw error;
      }
    });
    return emitAndReturn(await resolvePresetFile(rootDirectory));
  }
  return emitAndReturn(await resolvePresetFile(resolved.path));
}
async function parseResolvable(options, cwd = process.cwd()) {
  debug.resolve("Working directory:", cwd);
  debug.resolve("Parsing resolvable:", options.resolvable);
  const resolved = await resolveConfiguredAlias(options) || await resolveAlias(options) || await resolveNamespacedAlias(options) || await resolveLocalFile(options, cwd) || await resolveLocalDirectory(options, cwd) || await resolveGitHubRepository(options);
  if (!resolved) {
    throw new PresetError({
      code: "ERR_NOT_RESOLVED",
      details: `Could not resolve "${options.resolvable}" as an alias, a local file, a local directory or a repository.`
    });
  }
  return resolved;
}
async function resolveGitHubRepository(options) {
  debug.resolve("Trying to resolve as a GitHub repository.");
  const regexes = [
    /^([a-zA-Z][\w-]+)\/([a-zA-Z][\w-]+)(?:@([\w-\.]+))?$/,
    /^git@github\.com:([a-zA-Z][\w-]+)\/([a-zA-Z][\w-]+)(?:\.git)?(?:@([\w-\.]+))?$/,
    /^https?:\/\/(?:www\.)?github\.com\/([a-zA-Z][\w-]+)\/([a-zA-Z][\w-]+)(?:\.git)?(?:@([\w-\.]+))?/
  ];
  const repository = regexes.map((regex) => {
    const [matches, organization, repository2, tag] = options.resolvable.match(regex) ?? [];
    if (!matches) {
      return false;
    }
    const result = {
      type: "repository",
      organization,
      repository: repository2,
      tag,
      ssh: options.resolvable.startsWith("git@"),
      path: options.parsedOptions.path ?? ""
    };
    return result;
  }).filter(Boolean)?.shift();
  if (repository) {
    debug.resolve("Successfully resolved as a repository.");
    return repository;
  }
  return false;
}
async function resolveLocalDirectory(options, cwd) {
  const absolute = path__default.resolve(cwd, options.resolvable, options.parsedOptions.path ?? "");
  debug.resolve("Trying to resolve as a local directory:", absolute);
  try {
    if (fs__default.statSync(absolute).isDirectory()) {
      debug.resolve("Successfully resolved as a local directory.");
      return {
        type: "directory",
        path: absolute
      };
    }
  } catch {
  }
  return false;
}
async function resolveLocalFile(options, cwd) {
  const absolute = path__default.resolve(cwd, options.resolvable, options.parsedOptions.path ?? "");
  debug.resolve("Trying to resolve as a local file:", absolute);
  try {
    if (fs__default.statSync(absolute).isFile()) {
      debug.resolve("Successfully resolved as a local file.");
      return {
        type: "file",
        path: absolute
      };
    }
  } catch {
  }
  return false;
}
async function resolveAlias(options) {
  const aliases = {
    hybridly: {
      organization: "hybridly",
      repository: "preset",
      type: "repository"
    }
  };
  if (options.resolvable in aliases) {
    return aliases[options.resolvable];
  }
  return false;
}
async function resolveConfiguredAlias(options) {
  if (options.resolvable in config.aliases) {
    return config.aliases[options.resolvable];
  }
  return false;
}
async function resolveNamespacedAlias(options) {
  debug.resolve("Trying to resolve an alias.");
  if (!options.resolvable.match(/^([a-zA-Z][\w-]+):([a-zA-Z][\w-]+)$/)) {
    return false;
  }
  const [namespace, repository] = options.resolvable.split(":");
  return {
    type: "repository",
    ssh: false,
    organization: `${namespace}-presets`,
    repository,
    path: options.parsedOptions.path ?? "",
    tag: void 0
  };
}
async function resolvePresetFile(directory, cwd = process.cwd()) {
  debug.resolve(`Resolving preset file in "${directory}" with working directory "${cwd}".`);
  const pkg = invoke(() => {
    try {
      return JSON.parse(fs__default.readFileSync(path__default.resolve(cwd, directory, "package.json")));
    } catch (error) {
    }
    return false;
  });
  const ensureFile = async (file) => {
    if (!file) {
      return null;
    }
    try {
      const filepath2 = path__default.resolve(cwd, directory, file);
      if (fs__default.statSync(filepath2).isFile()) {
        return filepath2;
      }
    } catch {
    }
    return null;
  };
  const filepath = await ensureFile(pkg?.preset) ?? await ensureFile("preset.ts") ?? await ensureFile("src/preset.ts");
  if (!filepath) {
    throw new PresetError({
      code: "ERR_PRESET_FILE_NOT_FOUND",
      details: `Could not find a preset file in "${directory}".`
    });
  }
  debug.resolve(`Found "${filepath}".`);
  const DEPENDENCY_NAME = "@preset/core";
  return {
    rootDirectory: directory,
    presetFile: filepath,
    presetVersion: pkg?.devDependencies?.[DEPENDENCY_NAME] ?? pkg?.dependencies?.[DEPENDENCY_NAME]
  };
}
async function cloneRepository(preset, options) {
  const targetDirectory = path__default.resolve(fs__default.realpathSync(os__default.tmpdir()), "presets", preset.repository);
  const cloneWithSsh = options?.parsedOptions?.ssh === void 0 ? preset.ssh : options.parsedOptions.ssh;
  const tag = options?.parsedOptions?.tag === void 0 ? preset.tag : options.parsedOptions.tag;
  const repositoryUrl = cloneWithSsh ? `git@github.com:${preset.organization}/${preset.repository}.git` : `https://github.com/${preset.organization}/${preset.repository}`;
  if (fs__default.statSync(targetDirectory, { throwIfNoEntry: false })?.isDirectory()) {
    debug.resolve(`${repositoryUrl} already exists (${targetDirectory}), deleting it.`);
    await fs__default.promises.rm(targetDirectory, { recursive: true, force: true });
  }
  debug.resolve(`Cloning ${repositoryUrl} with${cloneWithSsh ? "" : "out"} SSH into ${targetDirectory}.`);
  if (process.env.VITEST) {
    throw new Error("Cloning repositories is not allowed in tests.");
  }
  try {
    await simpleGit__default().clone(repositoryUrl, targetDirectory, {
      "--depth": 1,
      ...tag && { "--branch": tag }
    });
  } catch (parent) {
    throw new PresetError({ code: "ERR_CLONE_PRESET", details: `Repository ${repositoryUrl} could not be cloned.`, parent });
  }
  return path__default.resolve(targetDirectory, preset.path ?? "");
}

async function applyPreset(options) {
  debug.apply(`Applying preset ${options.resolvable} into ${options.targetDirectory}.`);
  resetConfig();
  if (options.withoutGlobalConfig !== true) {
    debug.apply("Initializing global configuration.");
    await initializeConfig();
  }
  const resolved = await resolvePreset(options);
  const preset = await importPresetFile(resolved.presetFile);
  const context = await createPresetContext(preset, options, resolved);
  return await preset.apply(context);
}

const defaultOptions = {
  templates: "templates",
  from: "",
  to: "",
  whenConflict: "override",
  flatten: false,
  extractDotFiles: false
};
function renameDotfiles(input) {
  return input.replace(/^(.+[\/\\])*(.+\.dotfile)$/, (_, directory, dotfile) => path__default.resolve(`${directory}/.${dotfile.replace(".dotfile", "")}`));
}
const isFile$1 = (input) => fs__default.statSync(input, { throwIfNoEntry: false })?.isFile() ?? false;
const isDirectory = (input) => fs__default.statSync(input, { throwIfNoEntry: false })?.isDirectory() ?? false;
const extractTemplates = defineAction(
  "extract-templates",
  async ({ options, presetContext, actionContext }) => {
    const templatesPath = path__default.resolve(presetContext.localPreset.rootDirectory, options.templates, options.from);
    const targetPath = path__default.resolve(presetContext.applyOptions.targetDirectory, options.to);
    debug.action(actionContext.name, "Templates path:", templatesPath);
    debug.action(actionContext.name, "Target path:", targetPath);
    async function copyFileToFile(input, output) {
      output = renameDotfiles(output);
      if (await fs__default$1.pathExists(output) && options.whenConflict === "skip") {
        debug.action(actionContext.name, `Skipped copying to ${output}.`);
        return;
      }
      debug.action(actionContext.name, `Copying ${input} to ${output}.`);
      await fs__default$1.copy(input, output);
    }
    async function copyDirectoryToDirectory(input, output, glob) {
      debug.action(actionContext.name, `Matching ${glob || "**/**"} in`, input);
      const paths = await fg__default(glob || "**/**", {
        ignore: ["node_modules", ".git", "dist"],
        markDirectories: true,
        absolute: false,
        cwd: input,
        dot: options.extractDotFiles
      });
      debug.action(actionContext.name, `Matched ${paths.length} paths:`, paths);
      for (const relativePath of paths) {
        const resolvedInput = path__default.resolve(input, relativePath);
        const resolvedOutput = path__default.resolve(output, relativePath);
        await copyFileToFile(resolvedInput, resolvedOutput);
      }
    }
    if (isDirectory(templatesPath) && isFile$1(targetPath)) {
      throw new PresetError({ code: "ERR_ACTION_FAILED", details: "Can not extract a directory to a file." });
    }
    if (isFile$1(templatesPath) && isDirectory(targetPath)) {
      const finalTargetPath = options.flatten ? path__default.resolve(targetPath, path__default.basename(options.from)) : path__default.resolve(targetPath, options.from);
      await copyFileToFile(templatesPath, finalTargetPath);
      return true;
    }
    if (isFile$1(templatesPath) && isFile$1(targetPath)) {
      await copyFileToFile(templatesPath, targetPath);
      return true;
    }
    if (isDirectory(templatesPath) && isDirectory(targetPath)) {
      await copyDirectoryToDirectory(templatesPath, targetPath);
      return true;
    }
    await copyDirectoryToDirectory(
      path__default.resolve(presetContext.localPreset.rootDirectory, options.templates),
      targetPath,
      options.from
    );
    return true;
  },
  defaultOptions
);

const applyNestedPreset = defineAction("apply-nested-preset", async ({ options, presetContext, name }) => {
  const otherPresetOptions = {
    resolvable: options.preset,
    targetDirectory: presetContext.applyOptions.targetDirectory,
    parsedOptions: options.inheritsArguments ? presetContext.applyOptions.parsedOptions : {},
    rawArguments: [
      ...options.inheritsArguments ? presetContext.applyOptions.rawArguments : [],
      ...options.args ?? []
    ],
    actionContextId: presetContext.actions.at(-1)?.id
  };
  debug.action(name, "Applying a nested preset:", options.preset, otherPresetOptions);
  return await applyPreset(otherPresetOptions);
});

const ACTION_NAME = "install-packages";
async function getNodePackageManagerInstallArguments(cwd, options) {
  const packageManager = options.packageManager ?? await detectNodePackageManager(cwd) ?? config.defaultNodeAgent ?? "npm";
  const packageNames = wrap(options.install ?? options.packages);
  const args = options.additionalArgs || [];
  debug.action(ACTION_NAME, `Using package manager: ${packageManager}`);
  if (packageManager === "bun") {
    return [packageManager, [
      options.type,
      options.dev ? "-D" : "",
      ...args,
      ...packageNames
    ].filter(Boolean)];
  }
  if (packageManager === "npm") {
    return [packageManager, [
      options.type,
      options.dev ? "-D" : "",
      ...args,
      ...packageNames
    ].filter(Boolean)];
  }
  if (packageManager === "pnpm") {
    return [packageManager, [
      options.type,
      options.dev ? "-D" : "",
      ...args,
      ...packageNames
    ].filter(Boolean)];
  }
  if (packageManager === "yarn") {
    const command = invoke(() => {
      if (options.type === "update") {
        return "upgrade";
      }
      if (packageNames.length) {
        return "add";
      }
      return "install";
    });
    return [packageManager, [
      command,
      options.dev ? "-D" : "",
      ...args,
      ...packageNames
    ].filter(Boolean)];
  }
  throw new PresetError({ code: "ERR_ACTION_FAILED", details: `Package manager "${packageManager}" is not supported.` });
}
async function getComposerInstallArguments(cwd, options) {
  const packageNames = wrap(options.install ?? options.packages);
  const args = options.additionalArgs || [];
  return ["composer", [
    packageNames.length > 0 ? "require" : options.type,
    options.dev ? "--dev" : "",
    "--no-interaction",
    ...args,
    ...packageNames
  ].filter(Boolean)];
}
const installPackages = defineAction(
  ACTION_NAME,
  async ({ options, presetContext, actionContext }) => {
    const cwd = presetContext.applyOptions.targetDirectory;
    const args = await {
      node: () => getNodePackageManagerInstallArguments(cwd, options),
      php: () => getComposerInstallArguments(cwd, options)
    }[options.for]();
    debug.action(actionContext.name, `Installing packages in ${cwd}`, args);
    if (!["node", "php"].includes(options.for || "")) {
      throw new PresetError({ code: "ERR_ACTION_FAILED", details: `Environment "${options.for || "<not given>"}" is not supported.` });
    }
    return await execute(
      ...args,
      (log) => {
        actionContext.log.push(log);
        debug.action(actionContext.name, log);
      },
      cwd
    );
  },
  {
    for: "node",
    type: "install",
    packages: [],
    dev: false,
    additionalArgs: []
  }
);

const executeCommand = defineAction("execute-command", async ({ options, presetContext }) => {
  return await execute(
    options.command,
    options.arguments ?? [],
    options.data ?? (() => {
    }),
    presetContext.applyOptions.targetDirectory,
    { reject: !options.ignoreExitCode, env: options.env },
    options.ignoreExitCode
  );
});

// Detect either spaces or tabs but not both to properly handle tabs for indentation and spaces for alignment
const INDENT_REGEX = /^(?:( )+|\t+)/;

const INDENT_TYPE_SPACE = 'space';
const INDENT_TYPE_TAB = 'tab';

/**
Make a Map that counts how many indents/unindents have occurred for a given size and how many lines follow a given indentation.

The key is a concatenation of the indentation type (s = space and t = tab) and the size of the indents/unindents.

```
indents = {
	t3: [1, 0],
	t4: [1, 5],
	s5: [1, 0],
	s12: [1, 0],
}
```
*/
function makeIndentsMap(string, ignoreSingleSpaces) {
	const indents = new Map();

	// Remember the size of previous line's indentation
	let previousSize = 0;
	let previousIndentType;

	// Indents key (ident type + size of the indents/unindents)
	let key;

	for (const line of string.split(/\n/g)) {
		if (!line) {
			// Ignore empty lines
			continue;
		}

		let indent;
		let indentType;
		let use;
		let weight;
		let entry;
		const matches = line.match(INDENT_REGEX);

		if (matches === null) {
			previousSize = 0;
			previousIndentType = '';
		} else {
			indent = matches[0].length;
			indentType = matches[1] ? INDENT_TYPE_SPACE : INDENT_TYPE_TAB;

			// Ignore single space unless it's the only indent detected to prevent common false positives
			if (ignoreSingleSpaces && indentType === INDENT_TYPE_SPACE && indent === 1) {
				continue;
			}

			if (indentType !== previousIndentType) {
				previousSize = 0;
			}

			previousIndentType = indentType;

			use = 1;
			weight = 0;

			const indentDifference = indent - previousSize;
			previousSize = indent;

			// Previous line have same indent?
			if (indentDifference === 0) {
				// Not a new "use" of the current indent:
				use = 0;
				// But do add a bit to it for breaking ties:
				weight = 1;
				// We use the key from previous loop
			} else {
				const absoluteIndentDifference = indentDifference > 0 ? indentDifference : -indentDifference;
				key = encodeIndentsKey(indentType, absoluteIndentDifference);
			}

			// Update the stats
			entry = indents.get(key);
			entry = entry === undefined ? [1, 0] : [entry[0] + use, entry[1] + weight];

			indents.set(key, entry);
		}
	}

	return indents;
}

// Encode the indent type and amount as a string (e.g. 's4') for use as a compound key in the indents Map.
function encodeIndentsKey(indentType, indentAmount) {
	const typeCharacter = indentType === INDENT_TYPE_SPACE ? 's' : 't';
	return typeCharacter + String(indentAmount);
}

// Extract the indent type and amount from a key of the indents Map.
function decodeIndentsKey(indentsKey) {
	const keyHasTypeSpace = indentsKey[0] === 's';
	const type = keyHasTypeSpace ? INDENT_TYPE_SPACE : INDENT_TYPE_TAB;

	const amount = Number(indentsKey.slice(1));

	return {type, amount};
}

// Return the key (e.g. 's4') from the indents Map that represents the most common indent,
// or return undefined if there are no indents.
function getMostUsedKey(indents) {
	let result;
	let maxUsed = 0;
	let maxWeight = 0;

	for (const [key, [usedCount, weight]] of indents) {
		if (usedCount > maxUsed || (usedCount === maxUsed && weight > maxWeight)) {
			maxUsed = usedCount;
			maxWeight = weight;
			result = key;
		}
	}

	return result;
}

function makeIndentString(type, amount) {
	const indentCharacter = type === INDENT_TYPE_SPACE ? ' ' : '\t';
	return indentCharacter.repeat(amount);
}

function detectIndent(string) {
	if (typeof string !== 'string') {
		throw new TypeError('Expected a string');
	}

	// Identify indents while skipping single space indents to avoid common edge cases (e.g. code comments)
	// If no indents are identified, run again and include all indents for comprehensive detection
	let indents = makeIndentsMap(string, true);
	if (indents.size === 0) {
		indents = makeIndentsMap(string, false);
	}

	const keyOfMostUsedIndent = getMostUsedKey(indents);

	let type;
	let amount = 0;
	let indent = '';

	if (keyOfMostUsedIndent !== undefined) {
		({type, amount} = decodeIndentsKey(keyOfMostUsedIndent));
		indent = makeIndentString(type, amount);
	}

	return {
		amount,
		type,
		indent,
	};
}

const editFiles = defineAction("edit-files", async ({ options, presetContext, actionContext }) => {
  const paths = await fg__default(options.files, {
    ignore: ["node_modules", ".git", "dist"],
    markDirectories: true,
    absolute: false,
    cwd: presetContext.applyOptions.targetDirectory,
    dot: true
  });
  debug.action(actionContext.name, `Matched ${paths.length} paths:`, paths);
  for (const relativePath of paths) {
    const targetFile = path__default.resolve(presetContext.applyOptions.targetDirectory, relativePath);
    let content = fs__default.readFileSync(targetFile, { encoding: "utf-8" });
    for (const operation of wrap(options.operations)) {
      debug.action(actionContext.name, "Performing operation:", operation);
      if (operation.skipIf && await operation.skipIf(content, targetFile) === true) {
        continue;
      }
      if (operation.type === "update-content") {
        debug.action(actionContext.name, "Updating file content via callback.");
        content = operation.update(content);
      }
      if (operation.type === "replace-variables") {
        const prefix = operation.prefix ?? "@@";
        debug.action(actionContext.name, `Replacing given variables in file content, with prefix ${prefix}.`);
        for (let [variableName, variableValue] of Object.entries(operation.variables)) {
          variableName = variableName.startsWith(prefix) ? variableName : `${prefix}${variableName}`;
          variableValue = typeof variableValue === "function" ? variableValue(content)?.toString() : variableValue?.toString();
          content = content.replaceAll(variableName, variableValue ?? variableName);
          debug.action(actionContext.name, variableName, "->", variableValue);
        }
      }
      if (operation.type === "remove-line") {
        debug.action(actionContext.name, `Removing line(s) on match ${operation.match}.`);
        const lines = content.replace(/\r\n/, "\n").split("\n");
        const index = lines.findIndex((value) => value.match(operation.match));
        if (index === -1) {
          debug.action(actionContext.name, `Could not find ${operation.match}, skipping.`);
          continue;
        }
        const count = operation.count || 1;
        const start = operation.start || 0;
        debug.action(actionContext.name, `Using index ${index + start} and deleteCount ${count}`);
        lines.splice(index + start, count);
        content = lines.join("\n");
      }
      if (operation.type === "add-line") {
        const linesToAdd = wrap(operation.lines);
        debug.action(actionContext.name, `Adding ${linesToAdd.length} line(s)`);
        const lines = content.replace(/\r\n/, "\n").split("\n");
        const index = "match" in operation ? lines.findIndex((value) => value.match(operation.match)) : -1;
        if (index === -1 && "match" in operation) {
          debug.action(actionContext.name, `Could not find ${operation.match}, skipping.`);
          continue;
        }
        const indentLines = (targetLine, lines2) => {
          const operationIndent = operation.indent === void 0 ? true : operation.indent;
          if (operationIndent === true) {
            return lines2.map((line) => detectIndent(targetLine).indent + line);
          }
          if (typeof operationIndent === "number") {
            return lines2.map((line) => " ".repeat(operationIndent) + line);
          }
          if (typeof operationIndent === "string") {
            return lines2.map((line) => operationIndent + line);
          }
          return lines2;
        };
        if (typeof operation.position === "number") {
          lines.splice(operation.position, 0, ...indentLines(lines[operation.position], linesToAdd));
          debug.action(actionContext.name, `Added ${linesToAdd.length} line(s) to specified index.`);
        }
        if (operation.position === "prepend") {
          lines.splice(0, 0, ...linesToAdd);
          debug.action(actionContext.name, `Prepended ${linesToAdd.length} line(s).`);
        }
        if (operation.position === "append") {
          lines.push(...linesToAdd);
          debug.action(actionContext.name, `Appended ${linesToAdd.length} line(s).`);
        }
        if (operation.position === "after") {
          lines.splice(index + 1, 0, ...indentLines(lines[index], linesToAdd));
          debug.action(actionContext.name, `Added ${linesToAdd.length} line(s) at index ${index}.`);
        }
        if (operation.position === "before") {
          lines.splice(index, 0, ...indentLines(lines[index], linesToAdd));
          debug.action(actionContext.name, `Added ${linesToAdd.length} line(s) at index ${index}.`);
        }
        content = lines.join("\n");
      }
      if (operation.type === "edit-json") {
        const { indent } = detectIndent(content);
        let json = JSON.parse(content);
        if (operation.merge) {
          json = merge__default(json, operation.merge, {
            arrayMerge: (destinationArray, sourceArray) => [...new Set(destinationArray.concat(sourceArray))]
          });
        }
        if (operation.delete) {
          const pathsToDelete = wrap(operation.delete);
          pathsToDelete.forEach((path2) => unset__default(json, path2));
        }
        if (operation.replace) {
          json = operation.replace(json, objectWithoutKeys);
        }
        content = JSON.stringify(json, null, indent);
      }
    }
    fs__default.writeFileSync(targetFile, content, { encoding: "utf-8" });
  }
  return true;
});

const deletePaths = defineAction("delete-paths", async ({ options, actionContext, presetContext }) => {
  const pathsOrGlobs = wrap(options.paths);
  const deletePath = async (path2) => {
    debug.action(actionContext.name, `Deleting path at "${path2}".`);
    return await fs__default$1.rm(path2, { force: true, recursive: true, maxRetries: 5 });
  };
  for (const pathOrGlobToDelete of pathsOrGlobs) {
    const absolutePathToDelete = path__default.resolve(presetContext.applyOptions.targetDirectory, pathOrGlobToDelete);
    if (await fs__default$1.pathExists(absolutePathToDelete)) {
      await deletePath(absolutePathToDelete);
      continue;
    }
    const paths = await fg__default(pathOrGlobToDelete || "**/**", {
      ignore: ["node_modules", ".git", "dist"],
      absolute: false,
      cwd: presetContext.applyOptions.targetDirectory,
      dot: true
    });
    for (const pathToDelete of paths) {
      const absolutePathToDelete2 = path__default.resolve(presetContext.applyOptions.targetDirectory, pathToDelete);
      await deletePath(absolutePathToDelete2);
    }
  }
  return true;
});

const group = defineAction("group", async ({ options, presetContext, actionContext }) => {
  await options.handler();
  return presetContext.actions.filter((child) => child.groupContextId === actionContext.id).every((child) => child.status === "applied");
});

function shouldReturnDefaultResponse(presetContext) {
  return presetContext.options.interaction === false || presetContext.applyOptions.parsedOptions.interaction !== true || presetContext.applyOptions.parsedOptions.debug === true || process.stdout.isTTY === false;
}
async function inputPromptAction({ presetContext, actionContext, options }) {
  const promptId = node_crypto.randomUUID();
  debug.action(actionContext.name, `Prompting text for "${options.name}":`, options.text);
  debug.action(actionContext.name, "Default response:", options.default ?? "not defined");
  debug.action(actionContext.name, "Prompt ID", promptId);
  presetContext.prompts[options.name] = options.default;
  if (shouldReturnDefaultResponse(presetContext)) {
    debug.action(actionContext.name, "Interactions disabled, using default response.");
    return true;
  }
  return await new Promise((resolve) => {
    emitter.on("prompt:response", ({ id, response }) => {
      if (id !== promptId) {
        return debug.action(actionContext.name, "Received response for another prompt.");
      }
      presetContext.prompts[options.name] = response?.trim() || options.default;
      debug.action(actionContext.name, "Received response:", presetContext.prompts[options.name]);
      resolve(true);
    });
    debug.action(actionContext.name, `Emitting input event for "${options.name}".`);
    emitter.emit("prompt:input", {
      actionContextId: actionContext.id,
      id: promptId,
      isSelect: false,
      ...options
    });
  });
}
async function selectPromptAction({ presetContext, actionContext, options }) {
  const promptId = node_crypto.randomUUID();
  function getDefault(options2) {
    const optionIdx = options2.initial || 0;
    const choice = options2.choices[optionIdx];
    return typeof choice === "string" ? choice : choice.value || choice.title;
  }
  debug.action(actionContext.name, `Prompting selection for "${options.name}":`, options.text);
  debug.action(actionContext.name, "Default response:", getDefault(options) ?? "not defined");
  debug.action(actionContext.name, "Prompt ID", promptId);
  presetContext.prompts[options.name] = getDefault(options);
  if (shouldReturnDefaultResponse(presetContext)) {
    debug.action(actionContext.name, "Interactions disabled, using default response.");
    return true;
  }
  return await new Promise((resolve) => {
    emitter.on("prompt:response", ({ id, response }) => {
      if (id !== promptId) {
        return debug.action(actionContext.name, "Received response for another prompt.");
      }
      presetContext.prompts[options.name] = response?.trim() || getDefault(options);
      debug.action(actionContext.name, "Received response:", presetContext.prompts[options.name]);
      resolve(true);
    });
    debug.action(actionContext.name, `Emitting select event for "${options.name}".`);
    emitter.emit("prompt:select", {
      actionContextId: actionContext.id,
      id: promptId,
      isSelect: true,
      ...options
    });
  });
}
const prompt = defineAction("prompt", async ({
  presetContext,
  actionContext,
  options
}) => {
  const isSelect = Object.keys(options).includes("choices");
  return isSelect ? selectPromptAction({ presetContext, actionContext, options }) : inputPromptAction({ presetContext, actionContext, options });
});

const isFile = (input) => fs__default.statSync(input, { throwIfNoEntry: false })?.isFile() ?? false;
const renamePaths = defineAction("rename-paths", async ({ options, actionContext, presetContext }) => {
  const { transformer, paths } = options;
  const globPaths = await fg__default(paths || "**/**", {
    ignore: ["node_modules", ".git", "dist"],
    absolute: false,
    cwd: presetContext.applyOptions.targetDirectory,
    dot: true,
    onlyFiles: false
  });
  debug.action(actionContext.name, `Matched ${paths.length} paths:`, paths);
  const renamePath = async (oldPath, newPath) => {
    debug.action(actionContext.name, `Renaming path "${oldPath}" to "${newPath}".`);
    return await fs__default$1.rename(oldPath, newPath);
  };
  const getParsedPath = (pathOrGlob, absolutePathToRename) => {
    const ext = path__default.extname(pathOrGlob);
    const pathIsFile = isFile(absolutePathToRename);
    return {
      // Extract the file or directory name from a file path (if file without extension)
      name: path__default.basename(pathOrGlob, pathIsFile ? ext : ""),
      // Extract the file or directory name from a file path (if file with extension)
      base: path__default.basename(pathOrGlob),
      // If file extract the extension from a file path
      ...pathIsFile && { ext }
    };
  };
  for (const pathOrGlobToRename of globPaths) {
    const absolutePathToRename = path__default.resolve(
      presetContext.applyOptions.targetDirectory,
      pathOrGlobToRename
    );
    const baseDir = path__default.dirname(pathOrGlobToRename);
    const parsedPath = getParsedPath(pathOrGlobToRename, absolutePathToRename);
    const absoluteRenamedPath = path__default.resolve(
      presetContext.applyOptions.targetDirectory,
      baseDir,
      typeof transformer === "function" ? transformer(parsedPath) : transformer
    );
    await renamePath(absolutePathToRename, absoluteRenamedPath);
  }
  return true;
});

exports.PresetError = PresetError;
exports.applyNestedPreset = applyNestedPreset;
exports.applyPreset = applyPreset;
exports.cloneRepository = cloneRepository;
exports.createActionContext = createActionContext;
exports.createPresetContext = createPresetContext;
exports.defineAction = defineAction;
exports.definePreset = definePreset;
exports.deletePaths = deletePaths;
exports.editFiles = editFiles;
exports.emitter = emitter;
exports.executeCommand = executeCommand;
exports.extractTemplates = extractTemplates;
exports.finishActionContext = finishActionContext;
exports.finishPresetContext = finishPresetContext;
exports.getCurrentPresetContext = getCurrentPresetContext;
exports.group = group;
exports.importPresetFile = importPresetFile;
exports.installPackages = installPackages;
exports.parseResolvable = parseResolvable;
exports.popCurrentContext = popCurrentContext;
exports.prompt = prompt;
exports.renamePaths = renamePaths;
exports.resolveAlias = resolveAlias;
exports.resolveConfiguredAlias = resolveConfiguredAlias;
exports.resolveGitHubRepository = resolveGitHubRepository;
exports.resolveLocalDirectory = resolveLocalDirectory;
exports.resolveLocalFile = resolveLocalFile;
exports.resolveNamespacedAlias = resolveNamespacedAlias;
exports.resolvePreset = resolvePreset;
exports.resolvePresetFile = resolvePresetFile;
